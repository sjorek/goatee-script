// Generated by CoffeeScript 1.6.3
/*
Â© Copyright 2013 Stephan Jorek <stephan.jorek@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.
*/


(function() {
  var Expression, Stack, bindFn, global, isArray, isExpression, isFunction, isNumber, isString, root, toString, _ref, _ref1,
    __slice = [].slice;

  global = (function() {
    return this;
  })();

  Stack = require('./Stack').Stack;

  _ref = require('./Utility').Utility, bindFn = _ref.bindFn, toString = _ref.toString, isString = _ref.isString, isArray = _ref.isArray, isNumber = _ref.isNumber, isFunction = _ref.isFunction, isExpression = _ref.isExpression;

  root = (_ref1 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref1 : this;

  root.Expression = Expression = (function() {
    var _booleanize, _context, _errors, _evaluate, _execute, _global, _isProperty, _operations, _operator, _parser, _process, _scope, _stack, _stringify, _variables;

    _stack = void 0;

    _scope = null;

    _errors = null;

    _global = null;

    _variables = null;

    _operations = null;

    _parser = null;

    _context = {
      '$': _global,
      '@': _variables
    };

    _isProperty = function() {
      var p;
      p = _stack.parent();
      return (p != null) && p.operator.name === '.' && p.parameters[1] === _stack.current();
    };

    _execute = function(context, expression) {
      var e, result;
      if (!isExpression(expression)) {
        return expression;
      }
      _stack.push(context, expression);
      try {
        result = _process(context, expression);
      } catch (_error) {
        e = _error;
        (_errors != null ? _errors : _errors = []).push(e.message);
      } finally {
        _stack.pop();
      }
      return result;
    };

    Expression.evaluate = _evaluate = function(context, expression, variables, stack, scope) {
      var isGlobalScope, result;
      if (context == null) {
        context = {};
      }
      if (!isExpression(expression)) {
        return expression;
      }
      isGlobalScope = _stack === void 0;
      if (isGlobalScope) {
        _stack = new Stack(context, variables, stack, scope);
        _scope = _stack.scope;
        _errors = null;
        _global = _stack.global;
        _variables = _stack.variables;
        _evaluate = _execute;
      }
      result = _execute(context, expression);
      if (isGlobalScope) {
        _stack.destructor();
        _stack = void 0;
        _scope = null;
        _global = null;
        _variables = null;
        _evaluate = Expression.evaluate;
      }
      if (_errors != null) {
        console.log(_errors);
      }
      return result;
    };

    _process = function(context, expression) {
      var left, leftValue, operator, parameters, right, rightValue, value, values, _i, _j, _len, _len1;
      operator = expression.operator, parameters = expression.parameters;
      if (operator.chain) {
        if (parameters.length !== 2) {
          throw new Error("chain only supports 2 parameters");
        }
        left = parameters[0], right = parameters[1];
        context = _execute(context, left);
        if (left.vector) {
          values = [];
          for (_i = 0, _len = context.length; _i < _len; _i++) {
            leftValue = context[_i];
            rightValue = _execute(leftValue, right);
            value = operator.evaluate.call(leftValue, leftValue, rightValue);
            if (right.vector) {
              if (!isArray(value)) {
                throw new Error("vector operation did not return an array as expected: " + (JSON.stringify(operator)));
              }
              values.push.apply(values, value);
            } else if (value != null) {
              values.push(value);
            }
          }
          return values;
        }
        rightValue = _execute(context, right);
        return operator.evaluate.call(context, context, rightValue);
      }
      if (operator.raw) {
        return operator.evaluate.apply(context, parameters);
      }
      values = [];
      for (_j = 0, _len1 = parameters.length; _j < _len1; _j++) {
        rightValue = parameters[_j];
        values.push(_execute(context, rightValue));
      }
      return operator.evaluate.apply(context, values);
    };

    Expression.booleanize = _booleanize = function(value) {
      var item, _i, _len;
      if (isArray(value)) {
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          item = value[_i];
          if (_booleanize(item)) {
            return true;
          }
        }
        return false;
      }
      return Boolean(value);
    };

    Expression.stringify = _stringify = function(value) {
      var format, operator, parameter, parameters, _i, _len;
      if (!isExpression(value)) {
        return JSON.stringify(value);
      }
      operator = value.operator, parameters = value.parameters;
      format = operator.format;
      if (format != null) {
        return format.apply(this, parameters);
      } else if (parameters.length === 2) {
        return "(" + (_stringify(parameters[0])) + operator + (_stringify(parameters[1])) + ")";
      } else {
        format = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          format.push(_stringify(parameter));
        }
        return format.join(' ');
      }
    };

    Expression.operations = _operations = {
      '=': {
        evaluate: function(a, b) {
          return _variables[a] = b;
        }
      },
      '.': {
        chain: true,
        evaluate: function(a, b) {
          if (a !== _global && isFunction(b)) {
            return bindFn(b, a);
          } else {
            return b;
          }
        }
      },
      '&&': {
        raw: true,
        constant: true,
        evaluate: function(a, b) {
          a = _execute(this, a);
          if (!a) {
            return a;
          }
          b = _execute(this, b);
          return b;
        }
      },
      '||': {
        raw: true,
        constant: true,
        evaluate: function(a, b) {
          a = _execute(this, a);
          if (a) {
            return a;
          }
          b = _execute(this, b);
          return b;
        }
      },
      '?:': {
        constant: true,
        raw: true,
        vector: false,
        format: function(a, b, c) {
          return "(" + (_stringify(a)) + "?" + (_stringify(b)) + ":" + (_stringify(c)) + ")";
        },
        evaluate: function(a, b, c) {
          a = _execute(this, a);
          return _execute(this, _booleanize(a) ? b : c);
        }
      },
      '()': {
        vector: false,
        format: function() {
          var args, func;
          func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return func + '(' + args.join(',') + ')';
        },
        evaluate: function() {
          var args, func;
          func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (func == null) {
            throw new Error("Missing argument to call.");
          }
          if (!isFunction(func)) {
            throw new Error("Given argument is not callable.");
          }
          return func.apply(this, args);
        }
      },
      '[]': {
        chain: false,
        vector: false,
        format: function(a, b) {
          return "" + a + "[" + b + "]";
        },
        evaluate: function(a, b) {
          var index;
          if (isNumber(b) && b < 0) {
            index = (a.length != null ? a.length : 0) + b;
          } else {
            index = b;
          }
          return a[index];
        }
      },
      '{}': {
        chain: true,
        vector: false,
        format: function(a, b) {
          return "" + a + "{" + b + "}";
        },
        evaluate: function(a, b) {
          if (_booleanize(b)) {
            return a;
          } else {
            return void 0;
          }
        }
      },
      context: {
        alias: 'c',
        format: function(a) {
          return a;
        },
        vector: false,
        evaluate: function(a) {
          return _context[a];
        }
      },
      reference: {
        alias: 'r',
        format: function(a) {
          return a;
        },
        vector: false,
        evaluate: function(a) {
          var context, ref, value, _i;
          ref = _isProperty();
          value = this[a];
          if (ref) {
            if (this.hasOwnProperty(a)) {
              return value;
            }
          } else {
            if (_variables.hasOwnProperty(a)) {
              return _variables[a];
            }
            for (_i = _scope.length - 1; _i >= 0; _i += -1) {
              context = _scope[_i];
              if (context.hasOwnProperty(a)) {
                return context[a];
              }
            }
          }
          return value;
        }
      },
      primitive: {
        alias: 'p',
        constant: true,
        vector: false,
        format: function(a) {
          return JSON.stringify(a);
        },
        evaluate: function(a) {
          return a;
        }
      },
      block: {
        alias: 'b',
        format: function() {
          var statements;
          statements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return statements.join(';');
        },
        evaluate: function() {
          return arguments[arguments.length - 1];
        }
      },
      "if": {
        alias: 'i',
        raw: true,
        format: function(a, b, c) {
          if (c != null) {
            return "if (" + a + ") {" + b + "} else {" + c + "}";
          } else {
            return "if (" + a + ") {" + b + "}";
          }
        },
        evaluate: function(a, b, c) {
          if (_booleanize(_execute(this, a))) {
            return _execute(this, b);
          } else if (c != null) {
            return _execute(this, c);
          } else {
            return void 0;
          }
        }
      },
      array: {
        alias: 'a',
        format: function() {
          var elements;
          elements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return "[" + (elements.join(',')) + "]";
        },
        evaluate: function() {
          var elements;
          elements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return elements;
        }
      },
      object: {
        alias: 'o',
        format: function() {
          var buffer, i, k, _i, _len;
          buffer = [];
          for (i = _i = 0, _len = arguments.length; _i < _len; i = _i += 2) {
            k = arguments[i];
            buffer.push("" + k + ":" + arguments[i + 1]);
          }
          return "{" + (buffer.join(',')) + "}";
        },
        evaluate: function() {
          var i, k, object, _i, _len;
          object = {};
          for (i = _i = 0, _len = arguments.length; _i < _len; i = _i += 2) {
            k = arguments[i];
            object[k] = arguments[i + 1];
          }
          return object;
        }
      }
    };

    (function() {
      var key, value, _assign, _assignment, _bools, _evaluateRef, _formatRef, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _pairs, _raws, _ref2, _single;
      _evaluateRef = _operations.reference.evaluate;
      _formatRef = _operations.reference.format;
      _assignment = _operations['='].evaluate;
      _single = ['!', '~'];
      _pairs = ['+', '-', '*', '/', '%', '^', '>>>', '>>', '<<', '&', '|'];
      _bools = ['<', '>', '<=', '>=', '===', '!=='];
      _raws = ['==', '!='];
      _assign = ['=', '-=', '+=', '*=', '/=', '%=', '^=', '>>>=', '>>=', '<<=', '&=', '|='];
      for (_i = 0, _len = _single.length; _i < _len; _i++) {
        key = _single[_i];
        _operations[key] = {
          constant: true,
          evaluate: Function("return function(a) { return " + key + " a ; };")()
        };
      }
      _ref2 = _pairs.concat(_bools).concat(_raws);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        key = _ref2[_j];
        _operations[key] = {
          constant: true,
          evaluate: Function("return function(a,b) { return a " + key + " b ; };")()
        };
      }
      for (_k = 0, _len2 = _bools.length; _k < _len2; _k++) {
        key = _bools[_k];
        value = _operations[key];
        value.vector = false;
      }
      for (_l = 0, _len3 = _raws.length; _l < _len3; _l++) {
        key = _raws[_l];
        value = _operations[key];
        value.raw = true;
      }
      for (_m = 0, _len4 = _assign.length; _m < _len4; _m++) {
        key = _assign[_m];
        value = _operations[key] != null ? _operations[key] : _operations[key] = {};
        if (value.format == null) {
          value.format = (function() {
            var k;
            k = key;
            return function(a, b) {
              return "(" + (_formatRef(a)) + k + (_stringify(b)) + ")";
            };
          })();
        }
        if (key.length === 1) {
          continue;
        }
        if (value.evaluate == null) {
          value.evaluate = (function() {
            var _op;
            _op = _operations[key.substring(0, key.length - 1)].evaluate;
            return function(a, b) {
              return _assignment(a, _op(_evaluateRef(a), b));
            };
          })();
        }
      }
      for (key in _operations) {
        value = _operations[key];
        value.name = key;
        value.toString = (function() {
          var k;
          k = key;
          return function() {
            return k;
          };
        })();
        value.toJSON = function() {
          return this.name;
        };
        if ((value.alias != null) && (_operations[value.alias] == null)) {
          _operations[value.alias] = key;
        }
      }
    })();

    Expression.operator = _operator = function(name) {
      var op;
      if ((op = _operations[name]) != null) {
        if (op.name != null) {
          return op;
        } else {
          return _operator(op);
        }
      }
      throw new Error("operation not found: " + name);
    };

    function Expression(op, parameters) {
      var parameter, _i, _j, _len, _len1;
      this.parameters = parameters != null ? parameters : [];
      this.operator = _operator(op);
      this.constant = this.operator.constant === true;
      if (this.constant) {
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          if (isExpression(parameter) && !parameter.constant) {
            this.constant = false;
            break;
          }
        }
      }
      this.vector = this.operator.vector;
      if (this.vector === void 0) {
        this.vector = false;
        for (_j = 0, _len1 = parameters.length; _j < _len1; _j++) {
          parameter = parameters[_j];
          if (isExpression(parameter) && parameter.vector) {
            this.vector = true;
            break;
          }
        }
      }
      if (this.constant && this.operator.name !== _operations.primitive.name) {
        return new Expression('primitive', [this.evaluate(global)]);
      }
      return;
    }

    Expression.prototype.toString = function() {
      if (this.text !== void 0) {
        return this.text;
      }
      return this.text = _stringify(this);
    };

    Expression.prototype.toJSON = function(callback) {
      if (callback) {
        return callback(this);
      }
      return [this.operator.name].concat(this.parameters);
    };

    Expression.prototype.evaluate = function(context) {
      return _evaluate(context, this);
    };

    return Expression;

  })();

}).call(this);

/*
//@ sourceMappingURL=Expression.map
*/
