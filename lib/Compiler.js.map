{"version":3,"sources":["Compiler.coffee"],"names":[],"mappings":"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","file":"Compiler.js","sourceRoot":"/source/","sourcesContent":["###\n© Copyright 2013-2016 Stephan Jorek <stephan.jorek@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n<http://www.apache.org/licenses/LICENSE-2.0>\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\nimplied. See the License for the specific language governing\npermissions and limitations under the License.\n###\n\n{Expression}    = require './Expression'\n\n{Runtime:{\n  aliases\n}}              = require './Runtime'\n\n{Utility:{\n  arraySlice,\n  bindFunction,\n  isString,\n  isArray,\n  isNumber,\n  isFunction,\n  isExpression,\n  parse\n}}              = require './Utility'\n\nexports = module?.exports ? this\n\n## Compiling …\n# -------------\n#\n# … the goatee-scripts.\n\n# -------------\n# @class Compiler\n# @namespace GoateeScript\nexports.Compiler = class Compiler\n\n  _aliasSymbol = /^[a-zA-Z$_]$/\n  _operations = Expression.operations\n  _scalar     = _operations.scalar.name\n\n  _aliases    = aliases().join(',')\n  _arguments  = \",'\" + aliases().join(\"','\") + \"'\"\n\n  # -------------\n  # @function _wrap\n  # @param  {String}       code\n  # @param  {Object|Array} map (optional)\n  # @return {String}\n  # @private\n  _wrap = (code, map) ->\n    if map?\n      keys = if isArray map then map else (k for own k,v of map)\n      args = if keys.length is 0 then '' else \",'\" + keys.join(\"','\") + \"'\"\n      keys = keys.join ','\n    else\n      keys = _aliases\n      args = _arguments\n    \"(function(#{keys}) { return #{code}; }).call(this#{args})\"\n\n\n  # -------------\n  # @param  {Function}  [parseImpl=GoateeScript.Utility.parse]\n  # @constructor\n  constructor: (@parseImpl = parse) ->\n\n  # -------------\n  # @method compress\n  # @param  {Array}      ast\n  # @param  {Object}     [map={}] of aliases\n  # @return {Array.<Array,Object>}\n  compress: (ast, map = {}) ->\n    code = for o in ast\n      if not o?\n        '' + o\n      else if not o.length?\n        o\n      else if o.substring?\n        if _aliasSymbol.exec o\n          if map[o]? then ++map[o] else map[o]=1\n          o\n        else\n          JSON.stringify o\n      else\n        [c, map] = @compress(o, map)\n        c\n    [\"[#{code.join ','}]\", map]\n\n  # -------------\n  # @method expand\n  # @param  {String} opcode        A code-expression\n  # @return {Array}\n  expand: do ->\n    code = _wrap \"function(opcode){ return eval('[' + opcode + '][0]'); }\"\n    Function(\"return #{code}\")()\n\n  # -------------\n  # @method toExpression\n  # @param  {Array|String|Number|Boolean} [opcode=null] ast\n  # @return {Expression}\n  toExpression: (opcode) ->\n    state = false\n    if not opcode? or not (state = isArray opcode) or 2 > (state = opcode.length)\n      return new Expression 'scalar', \\\n        if state then opcode else [if state is 0 then undefined else opcode]\n\n    parameters = [].concat opcode\n    operator   = parameters.shift()\n    for value, index in parameters\n      parameters[index] = if isArray value then @toExpression value else value\n    new Expression(operator, parameters)\n\n  # -------------\n  # @method parse\n  # @param  {Array|String|Object} code, a String, opcode-Array or Object with\n  #                               toString method\n  # @return {Expression}\n  parse: (code) ->\n    return @parseImpl(code) if isString code\n    @toExpression(code)\n\n  # -------------\n  # @method evaluate\n  # @param  {Array|String|Object} code, a String, opcode-Array or Object with\n  #                               toString method\n  # @param  {Object}              context (optional)\n  # @param  {Object}              variables (optional)\n  # @param  {Array}               scope (optional)\n  # @param  {Array}               stack (optional)\n  # @return {mixed}\n  evaluate: (code, context, variables, scope, stack) ->\n    expression = @parse(code)\n    expression.evaluate(context, variables, scope, stack)\n\n  # -------------\n  # @method render\n  # @param  {Array|String|Object} code, a String, opcode-Array or Object with\n  #                               toString method\n  # @return {String}\n  render: (code) ->\n    @parse(code).toString()\n\n  # -------------\n  # @method save\n  # @param  {Expression} expression\n  # @param  {Function}   callback (optional)\n  # @param  {Boolean}    [compress=true]\n  # @return {Object.<String:op,Array:parameters>}\n  save: (expression, callback, compress = on) ->\n    if compress and expression.operator.name is _scalar\n      return expression.parameters\n    opcode = [\n      if compress and expression.operator.alias? \\\n        then expression.operator.alias else expression.operator.name\n    ]\n    opcode.push(\n      if isExpression parameter\n        @save parameter, callback, compress\n      else parameter\n    ) for parameter in expression.parameters\n    opcode\n\n  # -------------\n  # @method ast\n  # @param  {Array|String|Object} code, a String, opcode-Array or Object with\n  #                               toString method\n  # @param  {Function}            callback (optional)\n  # @param  {Boolean}             [compress=true]\n  # @return {Array|String|Number|true|false|null}\n  ast: (data, callback, compress = on) ->\n    expression = if isExpression data then data else @parse(data)\n    ast = @save(expression, callback, compress)\n    if compress then @compress ast else ast\n\n  # -------------\n  # @method stringyfy\n  # @param  {Array|String|Object} code, a String, opcode-Array or Object with\n  #                               toString method\n  # @param  {Function}            callback (optional)\n  # @param  {Boolean}             [compress=true]\n  # @return {String}\n  stringify: (data, callback, compress = on) ->\n    opcode = @ast(data, callback, compress)\n    if compress\n      \"[#{opcode[0]},#{JSON.stringify opcode[1]}]\"\n    else\n      JSON.stringify opcode\n\n  # -------------\n  # @method closure\n  # @param  {Array|String|Object} code, a String, opcode-Array or Object with\n  #                               toString method\n  # @param  {Function}            callback (optional)\n  # @param  {Boolean}             [compress=true]\n  # @return {Function}\n  closure: (data, callback, compress = on, prefix) ->\n    opcode = @ast(data, callback, compress)\n    if compress\n      code = _wrap(opcode)\n    else\n      code = JSON.stringify(opcode)\n\n    # …formerly:\n    #\n    #       Function \"#{prefix || ''}return [#{code}][0];\"\n    #\n    Function \"#{prefix || ''}return #{code};\"\n\n  # -------------\n  # @function _compile\n  # @param  {Boolean} compress\n  # @param  {String}  operator\n  # @param  {Array}   [parameters]\n  # @return {String}\n  # @private\n  _compile = (compress, operator, parameters...) ->\n\n    return JSON.stringify(operator) if parameters.length is 0\n\n    operation  = _operations[operator]\n    if isString operation\n      operator  = operation\n      operation = _operations[operator]\n\n    return JSON.stringify(parameters[0]) if operator is _scalar\n\n    id = if compress then operation.alias else \"_[\\\"#{operator}\\\"]\"\n    parameters = for parameter in parameters\n      if isArray parameter\n        _compile.apply(null, [compress].concat(parameter))\n      else\n        JSON.stringify(parameter)\n\n    \"#{id}(#{parameters.join ','})\"\n\n  # -------------\n  # @method load\n  # @param  {String|Array} data            opcode-String or -Array\n  # @param  {Boolean}      [compress=true]\n  # @return {String}\n  load: (data, compress = on) ->\n    opcode = if isArray data then data else @expand(data)\n    _compile.apply(null, [compress].concat(opcode))\n\n  # -------------\n  # @method compile\n  # @param  {Array|String|Object} code     a String, opcode-Array or\n  #                                        Object with toString method\n  # @param  {Function}            [callback]\n  # @param  {Boolean}             [compress=true]\n  # @return {String}\n  compile: (data, callback, compress = on) ->\n    opcode = if isArray data then data else @ast(data, callback, false)\n    @load(opcode, compress)\n"]}