// Generated by CoffeeScript 1.6.3
/*
Â© Copyright 2013 Stephan Jorek <stephan.jorek@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.
*/


(function() {
  var $1, $2, $3, $4, $5, $6, $7, $8, Grammar, Parser, aop, bop, exports, o, r, unwrap, yy, _ref,
    __hasProp = {}.hasOwnProperty;

  Parser = require('jison').Parser;

  yy = require('./Scope').Scope;

  exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : this;

  $1 = $2 = $3 = $4 = $5 = $6 = $7 = $8 = null;

  unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/;

  r = function(patternString, action) {
    var match;
    if (patternString.source != null) {
      patternString = patternString.source;
    }
    if (!action) {
      return [patternString, 'return;'];
    }
    action = (match = unwrap.exec(action)) ? match[1] : "(" + action + "())";
    return [patternString, "return " + action + ";"];
  };

  o = function(patternString, action, options) {
    var match;
    if (!action) {
      return [patternString, '$$ = $1;', options];
    }
    action = (match = unwrap.exec(action)) ? match[1] : "(" + action + "())";
    return [patternString, "$$ = " + action + ";", options];
  };

  aop = function(op) {
    return o("REFERENCE " + op + " Expression", function() {
      return new yy.Expression($2, [$1, $3]);
    });
  };

  bop = function(op) {
    return o("Expression " + op + " Expression", function() {
      return new yy.Expression($2, [$1, $3]);
    });
  };

  exports.Grammar = Grammar = {
    comment: 'Goatee Expression Parser',
    header: function(comment) {
      return "/* " + comment + " */\n(function() {\n";
    },
    footer: function() {
      return "\nparser.yy = require('./Scope').Scope;\n\n}).call(this);";
    },
    lex: {
      rules: [
        r(/\s+/, function() {}), r(/0[xX][a-fA-F0-9]+\b/, function() {
          return 'NUMBER';
        }), r(/([1-9][0-9]+|[0-9])(\.[0-9]+)?([eE][-+]?[0-9]+)?\b/, function() {
          return 'NUMBER';
        }), r(/null\b/, function() {
          return 'NULL';
        }), r(/true\b/, function() {
          return 'TRUE';
        }), r(/false\b/, function() {
          return 'FALSE';
        }), r(/if\b/, function() {
          return 'IF';
        }), r(/then\b/, function() {
          return 'THEN';
        }), r(/else\b/, function() {
          return 'ELSE';
        }), r(/return\b/, function() {
          return 'RETURN';
        }), r(/new\b/, function() {
          return 'NEW';
        }), r(/typeof\b/, function() {
          return 'TYPEOF';
        }), r(/void\b/, function() {
          return 'VOID';
        }), r(/instanceof\b/, function() {
          return 'INSTANCEOF';
        }), r(/yield\b/, function() {
          return 'YIELD';
        }), r(/this\b/, function() {
          return 'THIS';
        }), r(/[@$]/, function() {
          return 'CONTEXT';
        }), r(/[$_a-zA-Z]\w*/, function() {
          return 'REFERENCE';
        }), r(/"(\\x[a-fA-F0-9]{2}|\\u[a-fA-F0-9]{4}|\\[^xu]|[^\\"])*"/, function() {
          return 'STRING';
        }), r(/'(\\[\/'\\bfnrt]|\\u[a-fA-F0-9]{4}|[^\\'])*'/, function() {
          return 'STRING';
        }), r(/\/\*(?:.|[\r\n])*?\*\//, function() {}), r(/\./, function() {
          return '.';
        }), r(/\[/, function() {
          return '[';
        }), r(/\]/, function() {
          return ']';
        }), r(/\(/, function() {
          return '(';
        }), r(/\)/, function() {
          return ')';
        }), r(/\?/, function() {
          return '?';
        }), r(':', function() {
          return ':';
        }), r(';', function() {
          return ';';
        }), r(',', function() {
          return ',';
        }), r('{', function() {
          return '{';
        }), r('}', function() {
          return '}';
        }), r('-=', function() {
          return '-=';
        }), r(/\+=/, function() {
          return '+=';
        }), r(/\*=/, function() {
          return '*=';
        }), r(/\/=/, function() {
          return '/=';
        }), r('%=', function() {
          return '%=';
        }), r('--', function() {
          return '--';
        }), r(/\+\+/, function() {
          return '++';
        }), r('>>>=', function() {
          return '>>>=';
        }), r('>>=', function() {
          return '>>=';
        }), r('<<=', function() {
          return '<<=';
        }), r(/\&=/, function() {
          return '&=';
        }), r(/\|=/, function() {
          return '|=';
        }), r(/\^=/, function() {
          return '^=';
        }), r('===', function() {
          return '===';
        }), r('!==', function() {
          return '!==';
        }), r('==', function() {
          return '==';
        }), r('!=', function() {
          return '!=';
        }), r('<=', function() {
          return '<=';
        }), r('>=', function() {
          return '>=';
        }), r('<', function() {
          return '<';
        }), r('>', function() {
          return '>';
        }), r(/\&\&/, function() {
          return '&&';
        }), r(/\|\|/, function() {
          return '||';
        }), r('!', function() {
          return '!';
        }), r('-', function() {
          return '-';
        }), r(/\+/, function() {
          return '+';
        }), r(/\*/, function() {
          return '*';
        }), r(/\//, function() {
          return '/';
        }), r(/\^/, function() {
          return '^';
        }), r('%', function() {
          return '%';
        }), r('>>>', function() {
          return '>>>';
        }), r('>>', function() {
          return '>>';
        }), r('<<', function() {
          return '<<';
        }), r(/\&/, function() {
          return '&';
        }), r(/\|/, function() {
          return '|';
        }), r('~', function() {
          return '~';
        }), r('=', function() {
          return '=';
        }), r('$', function() {
          return 'EOF';
        })
      ]
    },
    operators: [['left', '.', '[', ']'], ['right', 'NEW'], ['left', '(', ')'], ['nonassoc', '++', '--'], ['right', '!', '~', 'TYPEOF', 'VOID', 'DELETE'], ['left', '*', '/', '%'], ['left', '+', '-'], ['left', '>>>', '>>', '<<'], ['left', '<=', '>=', '<', '>'], ['left', 'IN', 'INSTANCEOF'], ['left', '===', '!==', '==', '!='], ['left', '^'], ['left', '&'], ['left', '|'], ['left', '&&'], ['left', '||'], ['right', '?', ':'], ['right', 'YIELD'], ['right', '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '^=', '|='], ['left', ',']].reverse(),
    startSymbol: 'Script',
    bnf: {
      Script: [
        r('End', function() {
          return new yy.Expression('scalar', [void 0]);
        }), r('Statements End', function() {
          return $1;
        }), r('Seperator Statements End', function() {
          return $2;
        })
      ],
      Map: [
        r('End', function() {
          return new yy.Expression('scalar', [void 0]);
        }), r('Rules End', function() {
          return $1;
        }), r('Seperator Rules End', function() {
          return $2;
        })
      ],
      End: [r('EOF'), r('Seperator EOF')],
      Identifier: [o('THIS'), o('REFERENCE')],
      Statements: [
        o('Statement'), o('Statements Seperator Statement', function() {
          if ($1.operator.name === 'block') {
            $1.parameters.push($3);
            return $1;
          } else {
            return new yy.Expression('block', [$1, $3]);
          }
        })
      ],
      Rules: [
        o('Rule'), o('Rules Seperator Rule', function() {
          if ($1.operator.name === 'block') {
            $1.parameters.push($3);
            return $1;
          } else {
            return new yy.Expression('block', [$1, $3]);
          }
        })
      ],
      Rule: [
        o('REFERENCE : List', function() {
          return new yy.Expression('=', [$1, $3.operator.name === 'list' ? new yy.Expression('group', [$3]) : $3]);
        })
      ],
      Seperator: [r(';'), r('Seperator ;')],
      Statement: [o('Expression'), o('Conditional')],
      Parameters: [
        o('', function() {
          return [];
        }), o('Expression', function() {
          return [$1];
        }), o('Parameters , Expression', function() {
          return $1.concat($3);
        })
      ],
      Key: [o('Scalar'), o('REFERENCE')],
      KeyValues: [
        o('Key : Expression', function() {
          return [$1, $3];
        }), o('KeyValues , KeyValues', function() {
          return $1.concat($3);
        })
      ],
      Object: [
        o('{ }', function() {
          return new yy.Expression('object', []);
        }), o('{ KeyValues }', function() {
          return new yy.Expression('object', $2);
        })
      ],
      Elements: [
        o('', function() {
          return [];
        }), o('Expression', function() {
          return [$1];
        }), o('Elements , Elements', function() {
          return $1.concat($3.length === 0 ? [void 0] : $3);
        })
      ],
      Array: [
        o('[ Elements ]', function() {
          return new yy.Expression('array', $2);
        })
      ],
      Block: [
        o('{ Seperator }', function() {
          return new yy.Expression('scalar', [void 0]);
        }), o('{ Statements }', function() {
          return $2;
        }), o('{ Statements Seperator }', function() {
          return $2;
        })
      ],
      Conditional: [
        o('IF Group Block ELSE Conditional', function() {
          return new yy.Expression('if', [$2, $3, $5]);
        }), o('IF Group Block ELSE Block', function() {
          return new yy.Expression('if', [$2, $3, $5]);
        }), o('IF Group Block', function() {
          return new yy.Expression('if', [$2, $3]);
        }), o('IF Expression THEN Expression ELSE Statement', function() {
          if ($2.operator.name === 'group') {
            return new yy.Expression('if', [$2, $4, $6]);
          } else {
            return new yy.Expression('if', [new yy.Expression('group', [$2]), $4, $6]);
          }
        }), o('IF Expression THEN Statement', function() {
          if ($2.operator.name === 'group') {
            return new yy.Expression('if', [$2, $4]);
          } else {
            return new yy.Expression('if', [new yy.Expression('group', [$2]), $4]);
          }
        })
      ],
      IncDec: [o("++"), o("--")],
      Assignment: [
        o("IncDec Identifier", function() {
          return new yy.Expression($1, [$2, 0]);
        }), o("Identifier IncDec", function() {
          return new yy.Expression($2, [$1, 1]);
        }), aop('-='), aop('+='), aop('*='), aop('/='), aop('%='), aop('^='), aop('>>>='), aop('>>='), aop('<<='), aop('&='), aop('|='), aop('=')
      ],
      Scalar: [
        o('NUMBER', function() {
          return Number($1);
        }), o('+ NUMBER', function() {
          return +Number($2);
        }), o('- NUMBER', function() {
          return -Number($2);
        }), o('NULL', function() {
          return null;
        }), o('TRUE', function() {
          return true;
        }), o('FALSE', function() {
          return false;
        }), o('STRING', function() {
          return yy.escapeString($1);
        })
      ],
      Operation: [
        bop('*'), bop('/'), bop('%'), bop('+'), bop('-'), o('! Expression', function() {
          return new yy.Expression('!', [$2]);
        }), bop('<='), bop('>='), bop('<'), bop('>'), bop('==='), bop('!=='), bop('=='), bop('!='), bop('&&'), bop('||'), o('~ Expression', function() {
          return new yy.Expression('~', [$2]);
        }), bop('>>>'), bop('>>'), bop('<<'), bop('&'), bop('|'), bop('^')
      ],
      Literal: [
        o('Object'), o('Array'), o('Scalar', function() {
          return new yy.Expression('scalar', [$1]);
        })
      ],
      Scope: [
        o('CONTEXT', function() {
          return new yy.Expression('context', [$1[0]]);
        })
      ],
      Reference: [
        o('Identifier', function() {
          return new yy.Expression('reference', [$1]);
        }), o('Scope REFERENCE', function() {
          return new yy.Expression('.', [$1, new yy.Expression('property', [$2])]);
        }), o('Scope')
      ],
      Property: [
        o('Expression . REFERENCE', function() {
          return new yy.Expression('.', [$1, new yy.Expression('property', [$3])]);
        })
      ],
      List: [
        o('Statement'), o('List , Statement', function() {
          if ($1.operator.name === 'list') {
            $1.parameters.push($3);
            return $1;
          } else {
            return new yy.Expression('list', [$1, $3]);
          }
        })
      ],
      Group: [
        o('( List )', function() {
          return new yy.Expression('group', [$2]);
        })
      ],
      Expression: [
        o('Expression ? Expression : Expression', function() {
          return new yy.Expression('?:', [$1, $3, $5]);
        }), o('Expression ( Parameters )', function() {
          return new yy.Expression('()', [$1].concat($3));
        }), o('Expression [ Expression ]', function() {
          return new yy.Expression('[]', [$1, $3]);
        }), o('Assignment'), o('Reference'), o('Literal'), o('Operation'), o('Property'), o('Group')
      ]
    }
  };

  Grammar.tokens = (function() {
    var alternatives, bnf, known, name, tokenize, tokens;
    tokens = [];
    bnf = Grammar.bnf;
    known = {};
    tokenize = function(name, alternatives) {
      var alt, token, _i, _j, _len, _len1, _ref1, _results;
      _results = [];
      for (_i = 0, _len = alternatives.length; _i < _len; _i++) {
        alt = alternatives[_i];
        _ref1 = alt[0].split(' ');
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          token = _ref1[_j];
          if ((bnf[token] == null) && (known[token] == null)) {
            tokens.push(token);
          }
          known[token] = true;
        }
        if (name === 'Script') {
          alt[1] = "" + alt[1];
        }
        _results.push(alt);
      }
      return _results;
    };
    for (name in bnf) {
      if (!__hasProp.call(bnf, name)) continue;
      alternatives = bnf[name];
      bnf[name] = tokenize(name, alternatives);
    }
    return tokens.join(' ');
  })();

  Grammar.createParser = function(grammar, scope) {
    var parser;
    if (grammar == null) {
      grammar = Grammar;
    }
    if (scope == null) {
      scope = yy;
    }
    parser = new Parser(grammar);
    parser.yy = scope;
    return parser;
  };

}).call(this);

/*
//@ sourceMappingURL=Grammar.map
*/
