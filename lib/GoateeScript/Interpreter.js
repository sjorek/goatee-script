// Generated by CoffeeScript 1.6.3
/*
© Copyright 2013 Stephan Jorek <stephan.jorek@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.
*/


(function() {
  var Expression, Interpreter, arraySlice, bindFunction, exports, isArray, isExpression, isFunction, isNumber, isString, parse, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Expression = require('./Expression').Expression;

  _ref = require('./Utility').Utility, arraySlice = _ref.arraySlice, bindFunction = _ref.bindFunction, isString = _ref.isString, isArray = _ref.isArray, isNumber = _ref.isNumber, isFunction = _ref.isFunction, isExpression = _ref.isExpression, parse = _ref.parse;

  exports = (_ref1 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref1 : this;

  exports.Interpreter = Interpreter = (function() {
    var _aliasSymbol, _aliases, _arguments, _ast, _compile, _compress, _expand, _generate, _index, _load, _operations, _parse, _primitive, _reference, _save, _toExpression, _wrap;

    function Interpreter() {}

    _aliasSymbol = /^[a-zA-Z$_]$/;

    _operations = Expression.operations;

    _primitive = _operations.primitive.name;

    _reference = _operations.reference.name;

    _index = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'.split('');

    _arguments = ",'" + _index.join("','") + "'";

    _aliases = _index.join(',');

    Interpreter.generate = _generate = (function() {
      var alias, aliases, assemble, clean, index, interpreter, key, pattern, runtime, unwrap, value, _i, _len, _ref2;
      aliases = [];
      _ref2 = _index.reverse();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        alias = _ref2[_i];
        if (_operations[alias] == null) {
          aliases.push(alias);
        }
      }
      index = aliases.length;
      if (index === 0) {
        return;
      }
      for (key in _operations) {
        value = _operations[key];
        if (!((value.name != null) && (value.alias == null))) {
          continue;
        }
        _operations[value.alias = aliases[--index]] = key;
        if (index === 0) {
          break;
        }
      }
      runtime = {
        global: {
          name: 'global',
          alias: index === 0 ? '_g' : aliases[--index],
          code: 'null'
        },
        variables: {
          name: 'variables',
          alias: index === 0 ? '_v' : aliases[--index],
          code: '{}'
        },
        stack: {
          name: 'stack',
          alias: index === 0 ? 'st' : aliases[--index],
          code: '[]'
        },
        scope: {
          name: 'scope',
          alias: index === 0 ? 'sc' : aliases[--index],
          code: '[]'
        },
        call: {
          name: 'call',
          alias: index === 0 ? 'ca' : aliases[--index],
          code: 'Function.prototype.call'
        },
        slice: {
          name: 'slice',
          alias: index === 0 ? 'sl' : aliases[--index],
          code: 'Array.prototype.slice'
        },
        toString: {
          name: 'toString',
          alias: index === 0 ? 'tS' : aliases[--index],
          code: 'Object.prototype.toString'
        },
        evaluate: {
          name: 'evaluate',
          alias: index === 0 ? '_e' : aliases[--index],
          code: "function(c,e,v,_,$) {\n  var gS,$_;\n  if(!(isFunction(e) && e.name)){return e;}\n  gS = _global === null ? _evaluate : false;\n  if (gS) {\n    _evaluate = _execute;\n    _stack.length = 0;\n    _scope.length = 0;\n    _global = c||{};\n    _variables = v||{};\n  }\n  $_ = _execute(c,e)\n  if (gS) {\n    _global    = null;\n    _evaluate  = gS;\n  }\n}",
          evaluate: Expression.evaluate
        },
        execute: {
          name: 'execute',
          alias: index === 0 ? '_x' : aliases[--index],
          code: "function(c,e) {\n  var $_;\n  if(!(isFunction(e) && e.name)){return e;}\n  _scope.push(c);\n  _stack.push(e);\n  $_ = _process(c,e); /* ?!?!?!?! */\n  _scope.pop();\n  _stack.pop();\n  return $_;\n}",
          evaluate: Expression.execute
        },
        booleanize: {
          name: 'booleanize',
          alias: index === 0 ? '_b' : aliases[--index],
          evaluate: Expression.booleanize
        },
        isFunction: {
          name: 'isFunction',
          alias: index === 0 ? 'iF' : aliases[--index],
          evaluate: isFunction
        },
        bindFunction: {
          name: 'bindFunction',
          alias: index === 0 ? 'bF' : aliases[--index],
          code: "(function(bindFunction) {\n  return bindFunction ? function() {\n      return bindFunction.apply(arguments)\n    } : function() {\n      var f, c, a;\n      f = arguments[0],\n      c = arguments[1],\n      a = 3 <= arguments.length ? arraySlice(arguments, 2) : [];\n      if (a.length === 0) {\n        return function() { return f.call(c); };\n      } else {\n        return function() { return f.apply(c, a); };\n      }\n    }\n})(Function.prototype.bind)",
          evaluate: bindFunction
        },
        isArray: {
          name: 'isArray',
          alias: index === 0 ? 'iA' : aliases[--index],
          code: "Array.isArray /* || function(a) … */",
          evaluate: isArray
        },
        arraySlice: {
          name: 'arraySlice',
          alias: index === 0 ? 'aS' : aliases[--index],
          evaluate: arraySlice
        },
        hasProperty: {
          name: 'hasProperty',
          alias: index === 0 ? 'hP' : aliases[--index],
          code: "(function(hasProperty) {\n  return function() {\n    hasProperty.apply(arguments);\n  };\n})({}.hasOwnProperty)"
        },
        isProperty: {
          name: 'isProperty',
          alias: index === 0 ? 'iP' : aliases[--index],
          code: "function() {\n  if(_stack.length < 2){return false;}\n  var p = _stack.length > 1 ? _stack[_stack.length-2] : void(0),\n      c = _stack.length > 0 ? _stack[_stack.length-1] : void(0);\n  return p.toString() === '" + _operations.property.alias + "' && p[1] === c;\n}"
        },
        Number: {
          name: 'Number',
          alias: index === 0 ? 'Nu' : aliases[--index],
          code: "Number",
          evaluate: Number
        }
      };
      unwrap = /^function\s*\(([^\)]*)\)\s*\{\s*(\S[\s\S]*[;|\}])\s*\}$/;
      pattern = [/(\s|\n)+/g, ' ', /_assignment/g, _operations['='].alias, /_evaluateRef/g, _operations['reference'].alias, /_context.call\(this, a\)/g, "{'$$':_global,'@':_variables}[a]", /(_g)lobal/g, runtime.global.alias, /(_v)ariables/g, runtime.variables.alias, /_(sc)ope/g, runtime.scope.alias, /_(st)ack/g, runtime.stack.alias, /(_e)xecute/g, runtime.execute.alias, /(_b)ooleanize/g, runtime.booleanize.alias, /(__)slice\.call/g, runtime.arraySlice.alias, /_(sl)ice/g, runtime.slice.alias, /_(ca)ll/g, runtime.call.alias, /(i)s(A)rray/g, runtime.isArray.alias, /(i)s(N)umber/g, runtime.global.alias, /(Nu)mber/g, runtime.Number.alias, /(i)s(F)unction/g, runtime.isFunction.alias, /(b)ind(F)unction/g, runtime.bindFunction.alias, /_(i)s(P)roperty/g, runtime.isProperty.alias, /(h)as(P)roperty/g, runtime.hasProperty.alias, /([a-zA-Z]+)\.(h)asOwn(P)roperty\(/g, "" + runtime.hasProperty.alias + "($1,", /(_l)en/g, index === 0 ? "$1" : aliases[--index], /([a-z0-9])\s([^a-z0-9])/gi, '$1$2', /([^a-z0-9])\s([a-z0-9])/gi, '$1$2', /([^a-z0-9])\s([^a-z0-9])/gi, '$1$2', /([a-z0-9])\s([^a-z0-9])/gi, '$1$2', /([^a-z0-9])\s([a-z0-9])/gi, '$1$2', /([^a-z0-9])\s([^a-z0-9])/gi, '$1$2', /return(\S)/gi, 'return $1'];
      clean = function(key, value, code) {
        var search, _j, _len1;
        for (index = _j = 0, _len1 = pattern.length; _j < _len1; index = _j += 2) {
          search = pattern[index];
          code = code.replace(search, pattern[index + 1]);
        }
        if (key.length > 1 && key[key.length - 1] === '=') {
          alias = _operations[key.substring(0, key.length - 1)].alias;
          code = code.replace('_op', alias);
        }
        return code;
      };
      assemble = function(object) {
        var code, _results;
        _results = [];
        for (key in object) {
          value = object[key];
          if (!(value.name != null)) {
            continue;
          }
          code = clean(key, value, value.code != null ? value.code : value.evaluate.toString());
          _results.push(interpreter.push(['/* ', key, ' */\n', value.alias, '=', code, ';'].join('')));
        }
        return _results;
      };
      interpreter = [];
      assemble(runtime);
      assemble(_operations);
      interpreter = interpreter.join('\n');
      return function() {
        return interpreter;
      };
    })();

    Interpreter.compress = _compress = function(ast, map) {
      var c, code, o;
      if (map == null) {
        map = {};
      }
      code = (function() {
        var _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = ast.length; _i < _len; _i++) {
          o = ast[_i];
          if (o.length == null) {
            _results.push(o);
          } else if (o.substring != null) {
            if (_aliasSymbol.exec(o)) {
              if (map[o] != null) {
                ++map[o];
              } else {
                map[o] = 1;
              }
              _results.push(o);
            } else {
              _results.push(JSON.stringify(o));
            }
          } else {
            _ref2 = _compress(o, map), c = _ref2[0], map = _ref2[1];
            _results.push(c);
          }
        }
        return _results;
      })();
      return ["[" + (code.join(',')) + "]", map];
    };

    _wrap = function(code, map) {
      var args, k, keys, v;
      if (map != null) {
        keys = isArray(map) ? map : (function() {
          var _results;
          _results = [];
          for (k in map) {
            if (!__hasProp.call(map, k)) continue;
            v = map[k];
            _results.push(k);
          }
          return _results;
        })();
        args = keys.length === 0 ? '' : ",'" + keys.join("','") + "'";
        keys = keys.join(',');
      } else {
        keys = _aliases;
        args = _arguments;
      }
      return "(function(" + keys + ") { return " + code + "; }).call(this" + args + ")";
    };

    Interpreter.expand = _expand = (function() {
      var code;
      code = "function(opcode){ return eval('[' + opcode + '][0]'); }";
      return Function("return " + (_wrap(code)))();
    })();

    _toExpression = function(opcode) {
      var index, operator, parameters, value, _i, _len, _len1;
      _len = 0;
      if (!((opcode != null) || (_len = opcode.length || 0) > 1 || isArray(opcode))) {
        return new Expression('primitive', _len === 0 ? [opcode != null ? opcode : null] : opcode);
      }
      parameters = [].concat(opcode);
      operator = parameters.shift();
      for (index = _i = 0, _len1 = parameters.length; _i < _len1; index = ++_i) {
        value = parameters[index];
        parameters[index] = isArray(value) ? _toExpression(value) : value;
      }
      return new Expression(operator, parameters);
    };

    Interpreter.toExpression = function(opcode) {
      if (opcode == null) {
        opcode = null;
      }
      return _toExpression(opcode);
    };

    Interpreter.parse = _parse = function(code) {
      if (isString(code)) {
        return parse(code);
      }
      return _toExpression(code);
    };

    Interpreter.evaluate = function(code, context) {
      var expression;
      expression = _parse(code, context);
      return expression.evaluate(context);
    };

    Interpreter.render = function(code) {
      return _parse(code).toString();
    };

    Interpreter.save = _save = function(expression, callback, compress) {
      var opcode, parameter, _i, _len, _ref2;
      if (compress == null) {
        compress = true;
      }
      if (compress && expression.operator.name === _primitive) {
        return expression.parameters;
      }
      opcode = [compress && (expression.operator.alias != null) ? expression.operator.alias : expression.operator.name];
      _ref2 = expression.parameters;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        parameter = _ref2[_i];
        opcode.push(isExpression(parameter) ? _save(parameter, callback, compress) : parameter);
      }
      return opcode;
    };

    Interpreter.ast = _ast = function(data, callback, compress) {
      var ast, expression;
      if (compress == null) {
        compress = true;
      }
      expression = isExpression(data) ? data : _parse(data);
      ast = _save(expression, callback, compress);
      if (compress) {
        return _compress(ast);
      } else {
        return ast;
      }
    };

    Interpreter.stringify = function(data, callback, compress) {
      var opcode;
      if (compress == null) {
        compress = true;
      }
      opcode = _ast(data, callback, compress);
      if (compress) {
        return "[" + opcode[0] + "," + (JSON.stringify(opcode[1])) + "]";
      } else {
        return JSON.stringify(opcode);
      }
    };

    Interpreter.closure = function(data, callback, compress, prefix) {
      var code, opcode;
      if (compress == null) {
        compress = true;
      }
      opcode = _ast(data, callback, compress);
      if (compress) {
        code = _wrap.apply(null, opcode);
      } else {
        code = JSON.stringify(opcode);
      }
      return Function("" + (prefix || '') + "return " + code + ";");
    };

    _compile = function() {
      var compress, id, operation, operator, parameter, parameters;
      compress = arguments[0], operator = arguments[1], parameters = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (parameters.length === 0) {
        return JSON.stringify(operator);
      }
      operation = _operations[operator];
      if (isString(operation)) {
        operator = operation;
        operation = _operations[operator];
      }
      if (operator === _primitive) {
        return JSON.stringify(parameters[0]);
      }
      id = compress ? operation.alias : "_['" + operator + "']";
      parameters = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          if (isArray(parameter)) {
            _results.push(_compile.apply(null, [compress].concat(parameter)));
          } else {
            _results.push(JSON.stringify(parameter));
          }
        }
        return _results;
      })();
      return "" + id + "(" + (parameters.join(',')) + ")";
    };

    Interpreter.load = _load = function(data, compress) {
      var opcode;
      if (compress == null) {
        compress = true;
      }
      opcode = isArray(data) ? data : _expand(data);
      return _compile.apply(null, [compress].concat(opcode));
    };

    Interpreter.compile = function(data, callback, compress) {
      var opcode;
      if (compress == null) {
        compress = true;
      }
      opcode = isArray(data) ? data : _ast(data, callback, false);
      return _load(opcode, compress);
    };

    return Interpreter;

  })();

}).call(this);

/*
//@ sourceMappingURL=Interpreter.map
*/
