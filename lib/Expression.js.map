{"version":3,"sources":["Expression.coffee"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;AAAA;AAAA,MAAA,oHAAA;IAAA;;EAgBC,QAAiB,OAAA,CAAQ,SAAR,EAAjB;;QAUiB,OAAA,CAAQ,WAAR,EARjB,SACC,mBAAA,cACA,eAAA,UACA,eAAA,UACA,cAAA,SACA,eAAA,UACA,iBAAA,YACA,mBAAA;;EAGF,OAAA,wGAA4B;;;AAE5B;;;;;;;;;;AASA;;;;;;EAKA,OAAO,CAAC,UAAR,GAA2B;AAGzB,QAAA;;IAAA,MAAA,GAAgB;;IAChB,MAAA,GAAgB;;IAChB,OAAA,GAAgB;;IAChB,OAAA,GAAgB;;IAChB,MAAA,GAAgB;;IAChB,WAAA,GAAgB;;IAChB,OAAA,GAAgB;;IAGhB,OAAA,GAAgB;;IAGhB,SAAA,GAAgB;;IAGhB,SAAA,GAAgB;;IAGhB,UAAA,GAAgB;;IAGhB,SAAA,GAAgB;;IAGhB,QAAA,GAAgB;;IAGhB,WAAA,GAAgB;;;AAEhB;;;;;;;;;;IASA,WAAA,GAAgB,SAAA;AACd,UAAA;MAAA,CAAA,GAAI,MAAM,CAAC,QAAP,CAAA;aACJ,WAAA,IAAO,CAAC,CAAC,QAAQ,CAAC,IAAX,KAAmB,SAA1B,IAAwC,CAAC,CAAC,UAAW,CAAA,CAAA,CAAb,KAAmB,MAAM,CAAC,OAAP,CAAA;IAF7C;;;AAIhB;;;;;;;;;IAQA,UAAU,CAAC,OAAX,GAAqB,QAAA,GAAW,SAAC,OAAD,EAAU,UAAV;AAC9B,UAAA;MAAA,IAAA,CAAyB,YAAA,CAAa,UAAb,CAAzB;AAAA,eAAO,WAAP;;MACA,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,UAArB;AACA;QACE,MAAA,GAAS,QAAA,CAAS,OAAT,EAAkB,UAAlB,EADX;OAAA,aAAA;QAEM;QACJ,mBAAC,UAAA,UAAW,EAAZ,CAAe,CAAC,IAAhB,CAAqB,CAArB,EAHF;;MAIA,MAAM,CAAC,GAAP,CAAA;AACA,aAAO;IARuB;;;AAUhC;;;;;;;;;;;;IAWA,UAAU,CAAC,QAAX,GAAsB,SAAC,QAAD;MACpB,SAAA,GAAY;IADQ;;;AAItB;;;;;;;;;;IASA,UAAU,CAAC,MAAX,GAAoB,SAAA;MAClB,IAAW,iBAAA,IAAa,OAAO,CAAC,MAAR,KAAoB,CAA5C;QAAA,QAAA;;aACA;IAFkB;;;AAIpB;;;;;;;;;;;;;;;;IAeA,UAAU,CAAC,QAAX,GACA,SAAA,GAAY,SAAC,OAAD,EAAa,UAAb,EAAyB,SAAzB,EAAoC,KAApC,EAA2C,KAA3C;AACV,UAAA;;QADW,UAAQ;;MACnB,IAAA,CAAyB,YAAA,CAAa,UAAb,CAAzB;AAAA,eAAO,WAAP;;MAEA,aAAA,GAAoB;MACpB,IAAG,aAAH;QACE,MAAA,GAAgB,IAAA,KAAA,CAAM,OAAN,EAAe,SAAf,EAA0B,KAA1B,EAAiC,KAAjC;QAChB,MAAA,GAAY,MAAM,CAAC;QACnB,OAAA,GAAY;QACZ,OAAA,GAAY,MAAM,CAAC;QACnB,MAAA,GAAY,MAAM,CAAC;QACnB,SAAA,GAAY,SANd;;MAQA,MAAA,GAAS,QAAA,CAAS,OAAT,EAAkB,UAAlB;MAET,IAAG,aAAH;QACE,IAAkD,iBAAlD;UAAA,SAAA,CAAU,UAAV,EAAsB,MAAtB,EAA8B,MAA9B,EAAsC,OAAtC,EAAA;;QACA,MAAM,CAAC,UAAP,CAAA;QACA,MAAA,GAAY;QACZ,MAAA,GAAY;QACZ,OAAA,GAAY;QACZ,MAAA,GAAY;QACZ,SAAA,GAAY,UAAU,CAAC,SAPzB;;aASA;IAvBU;;;AAyBZ;;;;;;;;;;;;IAWA,QAAA,GAAW,SAAC,OAAD,EAAU,UAAV;AACT,UAAA;MAAC,sBAAA,QAAD,EAAU,wBAAA;MACV,IAAG,QAAQ,CAAC,KAAZ;QACE,IAAO,UAAU,CAAC,MAAX,KAAqB,CAA5B;AACE,gBAAU,IAAA,KAAA,CAAM,kCAAN,EADZ;;QAEC,oBAAD,EAAM;QACN,OAAA,GAAU,QAAA,CAAS,OAAT,EAAkB,IAAlB;QAEV,IAAG,IAAI,CAAC,MAAR;UACE,MAAA,GAAS;AACT,eAAA,yCAAA;;YACE,UAAA,GAAa,QAAA,CAAS,SAAT,EAAoB,KAApB;YACb,KAAA,GAAQ,QAAQ,CAAC,QAAQ,CAAC,IAAlB,CAAuB,SAAvB,EAAkC,SAAlC,EAA6C,UAA7C;YAER,IAAG,KAAK,CAAC,MAAT;cACE,IAAA,CAAO,OAAA,CAAQ,KAAR,CAAP;AACE,sBAAU,IAAA,KAAA,CAAM,wDAAA,GAAwD,CAAC,IAAI,CAAC,SAAL,CAAe,QAAf,CAAD,CAA9D,EADZ;;cAEA,MAAM,CAAC,IAAI,CAAC,KAAZ,CAAkB,MAAlB,EAA0B,KAA1B,EAHF;aAAA,MAIK,IAAG,aAAH;cACH,MAAM,CAAC,IAAP,CAAY,KAAZ,EADG;;AARP;AAUA,iBAAO,OAZT;;QAcA,UAAA,GAAa,QAAA,CAAS,OAAT,EAAkB,KAAlB;AACb,eAAO,QAAQ,CAAC,QAAQ,CAAC,IAAlB,CAAuB,OAAvB,EAAgC,OAAhC,EAAyC,UAAzC,EArBT;;MAuBA,IAAG,QAAQ,CAAC,GAAZ;AACE,eAAO,QAAQ,CAAC,QAAQ,CAAC,KAAlB,CAAwB,OAAxB,EAAiC,UAAjC,EADT;;MAGA,MAAA,GAAS;AACT,WAAA,8CAAA;;QAAA,MAAM,CAAC,IAAP,CAAY,QAAA,CAAS,OAAT,EAAkB,UAAlB,CAAZ;AAAA;aACA,QAAQ,CAAC,QAAQ,CAAC,KAAlB,CAAwB,OAAxB,EAAiC,MAAjC;IA9BS;;;AAgCX;;;;;;;;;;;;IAWA,UAAU,CAAC,UAAX,GAAwB,WAAA,GAAc,SAAC,KAAD;AACpC,UAAA;MAAA,IAAG,OAAA,CAAQ,KAAR,CAAH;AACE,aAAA,uCAAA;;UACE,IAAG,WAAA,CAAY,IAAZ,CAAH;AACE,mBAAO,KADT;;AADF;AAGA,eAAO,MAJT;;AAKA,aAAO,OAAA,CAAQ,KAAR;IAN6B;;;AAQtC;;;;;;;;;;;;;;IAaA,UAAU,CAAC,SAAX,GAAuB,UAAA,GAAa,SAAC,KAAD;AAClC,UAAA;MAAA,IAAG,CAAI,YAAA,CAAa,KAAb,CAAP;AACE,eAAO,IAAI,CAAC,SAAL,CAAe,KAAf,EADT;;MAGC,iBAAA,QAAD,EAAU,mBAAA;MACT,SAAuB,SAAvB;MAED,IAAG,cAAH;AACE,eAAO,MAAM,CAAC,KAAP,CAAa,IAAb,EAAmB,UAAnB,EADT;OAAA,MAEK,IAAG,UAAU,CAAC,MAAX,KAAqB,CAAxB;eAEH,EAAA,GAAE,CAAC,UAAA,CAAW,UAAW,CAAA,CAAA,CAAtB,CAAD,CAAF,GAA8B,QAA9B,GAAwC,CAAC,UAAA,CAAW,UAAW,CAAA,CAAA,CAAtB,CAAD,EAFrC;OAAA,MAAA;QAKH,MAAA,GAAS;AACT,aAAA,4CAAA;;UAAA,MAAM,CAAC,IAAP,CAAY,UAAA,CAAW,SAAX,CAAZ;AAAA;eACA,MAAM,CAAC,IAAP,CAAY,GAAZ,EAPG;;IAT6B;;;AAkBpC;;;;;;;;;;IASA,UAAU,CAAC,UAAX,GAAwB,WAAA,GAGtB;MAAA,GAAA,EACE;QAAA,QAAA,EAAU,SAAC,CAAD,EAAG,CAAH;iBACR,MAAO,CAAA,CAAA,CAAP,GAAY;QADJ,CAAV;OADF;MAoCA,GAAA,EACE;QAAA,KAAA,EAAU,IAAV;QAYA,QAAA,EAAU,SAAC,CAAD,EAAG,CAAH;UACR,IAAG,CAAA,KAAO,OAAP,IAAmB,UAAA,CAAW,CAAX,CAAtB;mBAAwC,YAAA,CAAa,CAAb,EAAgB,CAAhB,EAAxC;WAAA,MAAA;mBAA+D,EAA/D;;QADQ,CAZV;OArCF;MAoGA,IAAA,EACE;QAAA,GAAA,EAAU,IAAV;QACA,QAAA,EAAU,IADV;QAEA,QAAA,EAAU,SAAC,CAAD,EAAG,CAAH;UACR,CAAA,GAAI,QAAA,CAAS,IAAT,EAAe,CAAf;UACJ,IAAG,CAAI,CAAP;AACE,mBAAO,EADT;;UAEA,CAAA,GAAI,QAAA,CAAS,IAAT,EAAe,CAAf;AACJ,iBAAO;QALC,CAFV;OArGF;MA+GA,IAAA,EACE;QAAA,GAAA,EAAU,IAAV;QACA,QAAA,EAAU,IADV;QAEA,QAAA,EAAU,SAAC,CAAD,EAAG,CAAH;UACR,CAAA,GAAI,QAAA,CAAS,IAAT,EAAe,CAAf;UACJ,IAAG,CAAH;AACE,mBAAO,EADT;;UAEA,CAAA,GAAI,QAAA,CAAS,IAAT,EAAe,CAAf;AACJ,iBAAO;QALC,CAFV;OAhHF;MAyKA,IAAA,EACE;QAAA,QAAA,EAAU,IAAV;QACA,GAAA,EAAU,IADV;QAEA,MAAA,EAAQ,KAFR;QAGA,MAAA,EAAQ,SAAC,CAAD,EAAG,CAAH,EAAK,CAAL;iBACN,GAAA,GAAG,CAAC,UAAA,CAAW,CAAX,CAAD,CAAH,GAAkB,GAAlB,GAAoB,CAAC,UAAA,CAAW,CAAX,CAAD,CAApB,GAAmC,GAAnC,GAAqC,CAAC,UAAA,CAAW,CAAX,CAAD,CAArC,GAAoD;QAD9C,CAHR;QAKA,QAAA,EAAU,SAAC,CAAD,EAAG,CAAH,EAAK,CAAL;UACR,CAAA,GAAI,QAAA,CAAS,IAAT,EAAe,CAAf;iBACJ,QAAA,CAAS,IAAT,EAAkB,WAAA,CAAY,CAAZ,CAAH,GAAsB,CAAtB,GAA6B,CAA5C;QAFQ,CALV;OA1KF;MAoLA,IAAA,EACE;QAAA,MAAA,EAAQ,KAAR;QACA,MAAA,EAAQ,SAAA;AACN,cAAA;UADO,kBAAE;iBACT,CAAA,GAAI,GAAJ,GAAU,CAAC,CAAC,IAAF,CAAO,GAAP,CAAV,GAAwB;QADlB,CADR;QAGA,QAAA,EAAU,SAAA;AACR,cAAA;UADS,kBAAE;UACX,IAAmD,SAAnD;AAAA,kBAAU,IAAA,KAAA,CAAM,2BAAN,EAAV;;UACA,IAAA,CAAyD,UAAA,CAAW,CAAX,CAAzD;AAAA,kBAAU,IAAA,KAAA,CAAM,iCAAN,EAAV;;iBACA,CAAC,CAAC,KAAF,CAAQ,IAAR,EAAc,CAAd;QAHQ,CAHV;OArLF;MA8LA,IAAA,EACE;QAAA,KAAA,EAAO,KAAP;QACA,MAAA,EAAQ,KADR;QAEA,MAAA,EAAQ,SAAC,CAAD,EAAG,CAAH;iBAAY,CAAD,GAAG,GAAH,GAAM,CAAN,GAAQ;QAAnB,CAFR;QAGA,QAAA,EAAU,SAAC,CAAD,EAAG,CAAH;UAGR,IAAG,QAAA,CAAS,CAAT,CAAA,IAAgB,CAAA,GAAI,CAAvB;mBACE,CAAE,CAAA,CAAI,gBAAH,GAAkB,CAAC,CAAC,MAApB,GAAgC,CAAjC,CAAA,GAAsC,CAAtC,EADJ;WAAA,MAAA;mBAGE,CAAE,CAAA,CAAA,EAHJ;;QAHQ,CAHV;OA/LF;MA4NA,OAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,MAAA,EAAU,SAAC,CAAD;AACR,kBAAO,CAAP;AAAA,iBACO,GADP;qBACiB;AADjB,iBAEO,IAFP;qBAEiB;AAFjB,iBAGO,IAHP;qBAGiB;AAHjB,iBAIO,IAJP;qBAIiB;AAJjB,iBAKO,IALP;qBAKiB;AALjB,iBAMO,IANP;AAAA,iBAMa,IANb;AAAA,iBAMmB,IANnB;AAAA,iBAMyB,IANzB;AAAA,iBAM+B,IAN/B;AAAA,iBAMqC,IANrC;AAAA,iBAM2C,IAN3C;AAAA,iBAMiD,IANjD;AAAA,iBAMuD,IANvD;AAAA,iBAM6D,IAN7D;qBAOI,SAAA,GAAU,CAAE,CAAA,CAAA,CAAZ,GAAe;AAPnB,iBAQO,IARP;AAAA,iBAQa,IARb;AAAA,iBAQmB,IARnB;AAAA,iBAQyB,IARzB;AAAA,iBAQ+B,IAR/B;AAAA,iBAQqC,IARrC;AAAA,iBAQ2C,IAR3C;AAAA,iBAQiD,IARjD;AAAA,iBAQuD,IARvD;AAAA,iBAQ6D,IAR7D;qBASI,uBAAA,GAAuB,CAAC,CAAE,CAAA,CAAA,CAAF,GAAK,CAAN,CAAvB,GAA+B;AATnC;qBAUO;AAVP;QADQ,CADV;QAaA,MAAA,EAAU,KAbV;QAcA,QAAA,EAAU,SAAC,CAAD;AACR,kBAAO,CAAP;AAAA,iBACO,GADP;qBACiB;AADjB,iBAEO,IAFP;qBAEiB;AAFjB,iBAGO,IAHP;qBAGiB;AAHjB,iBAIO,IAJP;qBAIiB;AAJjB,iBAKO,IALP;qBAKiB,MAAM,CAAC;AALxB,iBAMO,IANP;AAAA,iBAMa,IANb;AAAA,iBAMmB,IANnB;AAAA,iBAMyB,IANzB;AAAA,iBAM+B,IAN/B;AAAA,iBAMqC,IANrC;AAAA,iBAM2C,IAN3C;AAAA,iBAMiD,IANjD;AAAA,iBAMuD,IANvD;AAAA,iBAM6D,IAN7D;AAAA,iBAOO,IAPP;AAAA,iBAOa,IAPb;AAAA,iBAOmB,IAPnB;AAAA,iBAOyB,IAPzB;AAAA,iBAO+B,IAP/B;AAAA,iBAOqC,IAPrC;AAAA,iBAO2C,IAP3C;AAAA,iBAOiD,IAPjD;AAAA,iBAOuD,IAPvD;AAAA,iBAO6D,IAP7D;qBAQI,MAAO,CAAG,CAAE,CAAA,CAAA,CAAF,KAAQ,GAAX,GAAoB,CAAE,CAAA,CAAA,CAAtB,GAA8B,MAAM,CAAC,MAAP,GAAc,CAAE,CAAA,CAAA,CAAhB,GAAmB,CAAjD;AARX;qBASO;AATP;QADQ,CAdV;OA7NF;MAwPA,QAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,MAAA,EAAU,SAAC,CAAD;iBAAO;QAAP,CADV;QAEA,MAAA,EAAU,KAFV;QAGA,QAAA,EAAU,SAAC,CAAD;UACR,IAAG,CAAA,KAAK,aAAL,IAAsB,CAAA,KAAK,WAA3B,IAA0C,CAAA,KAAK,WAAlD;mBACE,OADF;WAAA,MAAA;mBAGE,IAAK,CAAA,CAAA,EAHP;;QADQ,CAHV;OAzPF;MAmQA,SAAA,EACE;QAAA,KAAA,EAAQ,GAAR;QACA,MAAA,EAAQ,SAAC,CAAD;UACN,IAAG,CAAA,KAAK,MAAR;mBACE,OADF;WAAA,MAAA;mBAGE,gBAAA,GAAgB,CAAC,IAAI,CAAC,SAAL,CAAe,CAAf,CAAD,CAAhB,GAAkC,IAAlC,GAAsC,EAHxC;;QADM,CADR;QAMA,MAAA,EAAU,KANV;QAOA,QAAA,EAAU,SAAC,CAAD;AACR,cAAA;UAAA,IAAG,CAAA,KAAK,MAAR;mBACE,KADF;WAAA,MAEK,IAAG,CAAA,KAAK,aAAL,IAAsB,CAAA,KAAK,WAA3B,IAA0C,CAAA,KAAK,WAAlD;mBACH,OADG;WAAA,MAAA;YAGH,CAAA,GAAI,IAAK,CAAA,CAAA;YACT,IAAG,IAAA,KAAQ,MAAX;AACE,qBAAO,EADT;;YAEA,IAAG,WAAA,CAAA,CAAH;cACE,IAAY,IAAI,CAAC,cAAL,CAAoB,CAApB,CAAZ;AAAA,uBAAO,EAAP;eADF;aAAA,MAAA;cAGE,IAAoB,MAAM,CAAC,cAAP,CAAsB,CAAtB,CAApB;AAAA,uBAAO,MAAO,CAAA,CAAA,EAAd;;AAEA,mBAAA,sCAAA;;oBAA2B,CAAC,CAAC,cAAF,CAAiB,CAAjB;AACzB,yBAAO,CAAE,CAAA,CAAA;;AADX,eALF;;mBAOA,EAbG;;QAHG,CAPV;OApQF;MA4SA,MAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,QAAA,EAAU,IADV;QAEA,MAAA,EAAU,KAFV;QAGA,MAAA,EAAU,SAAC,CAAD;UAAO,IAAG,CAAA,KAAK,MAAR;mBAAuB,GAAvB;WAAA,MAAA;mBAA+B,IAAI,CAAC,SAAL,CAAe,CAAf,EAA/B;;QAAP,CAHV;QAIA,QAAA,EAAU,SAAC,CAAD;iBAAO;QAAP,CAJV;OA7SF;MAoTA,KAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,MAAA,EAAU,SAAA;AAAU,cAAA;UAAT;iBAAS,CAAC,CAAC,IAAF,CAAO,GAAP;QAAV,CADV;QAEA,QAAA,EAAU,SAAA;iBAAG,SAAU,CAAA,SAAS,CAAC,MAAV,GAAiB,CAAjB;QAAb,CAFV;OArTF;MA0TA,IAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,MAAA,EAAU,SAAA;AAAU,cAAA;UAAT;iBAAS,EAAA,GAAE,CAAC,CAAC,CAAC,IAAF,CAAO,GAAP,CAAD;QAAZ,CADV;QAEA,QAAA,EAAU,SAAA;iBAAG,SAAU,CAAA,SAAS,CAAC,MAAV,GAAiB,CAAjB;QAAb,CAFV;OA3TF;MAgUA,KAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,MAAA,EAAU,SAAC,CAAD;iBAAO,GAAA,GAAI,CAAJ,GAAM;QAAb,CADV;QAEA,QAAA,EAAU,SAAC,CAAD;iBAAO,QAAA,CAAS,IAAT,EAAe,CAAf;QAAP,CAFV;OAjUF;MAuUA,IAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,GAAA,EAAU,IADV;QAEA,MAAA,EAAU,SAAC,CAAD,EAAG,CAAH,EAAK,CAAL;UACR,IAAG,SAAH;mBACE,KAAA,GAAM,CAAN,GAAQ,IAAR,GAAY,CAAZ,GAAc,UAAd,GAAwB,CAAxB,GAA0B,IAD5B;WAAA,MAAA;mBAGE,KAAA,GAAM,CAAN,GAAQ,IAAR,GAAY,CAAZ,GAAc,IAHhB;;QADQ,CAFV;QAOA,QAAA,EAAU,SAAC,CAAD,EAAG,CAAH,EAAK,CAAL;UACR,IAAG,WAAA,CAAY,QAAA,CAAS,IAAT,EAAe,CAAf,CAAZ,CAAH;mBACE,QAAA,CAAS,IAAT,EAAe,CAAf,EADF;WAAA,MAEK,IAAG,SAAH;mBACH,QAAA,CAAS,IAAT,EAAe,CAAf,EADG;WAAA,MAAA;mBAGH,OAHG;;QAHG,CAPV;OAxUF;MAoWA,KAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,MAAA,EAAU,SAAA;AAAU,cAAA;UAAT;iBAAS,GAAA,GAAG,CAAC,CAAC,CAAC,IAAF,CAAO,GAAP,CAAD,CAAH,GAAe;QAAzB,CADV;QAEA,QAAA,EAAU,SAAA;AAAU,cAAA;UAAT;iBAAS;QAAV,CAFV;OArWF;MA0WA,MAAA,EACE;QAAA,KAAA,EAAU,GAAV;QACA,MAAA,EAAU,SAAA;AACR,cAAA;UAAA,CAAA,GAAI;AACJ,eAAA,sDAAA;;YAAA,CAAC,CAAC,IAAF,CAAU,CAAD,GAAG,GAAH,GAAM,SAAU,CAAA,CAAA,GAAE,CAAF,CAAzB;AAAA;iBACA,GAAA,GAAG,CAAC,CAAC,CAAC,IAAF,CAAO,GAAP,CAAD,CAAH,GAAe;QAHP,CADV;QAKA,QAAA,EAAU,SAAA;AACR,cAAA;UAAA,CAAA,GAAI;AACJ,eAAA,sDAAA;;YAAA,CAAE,CAAA,CAAA,CAAF,GAAO,SAAU,CAAA,CAAA,GAAE,CAAF;AAAjB;iBACA;QAHQ,CALV;OA3WF;;;;AAqXF;;;;;;;;IAOG,CAAA,SAAA;AAED,UAAA;MAAA,UAAA,GAAc,WAAW,CAAC,SAAS,CAAC;MACpC,SAAA,GAAc,SAAC,CAAD;eACZ,UAAU,CAAC,IAAX,CAAgB,IAAhB,EAAsB,CAAtB,CAAwB,CAAC,OAAzB,CAAiC,WAAjC,EAA6C,WAA7C;MADY;MAGd,QAAA,GAAc,WAAW,CAAC,SAAS,CAAC;MACpC,WAAA,GAAc,WAAY,CAAA,GAAA,CAAI,CAAC;MAE/B,OAAA,GAAU,CAAC,IAAD,EAAO,IAAP;MACV,OAAA,GAAU,CAAC,GAAD,EAAM,GAAN;MACV,MAAA,GAAU,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,KAA/B,EAAsC,IAAtC,EAA4C,IAA5C,EAAkD,GAAlD,EAAuD,GAAvD;MACV,MAAA,GAAU,CAAC,GAAD,EAAM,GAAN,EAAW,IAAX,EAAiB,IAAjB,EAAuB,KAAvB,EAA8B,KAA9B;MACV,KAAA,GAAU,CAAC,IAAD,EAAO,IAAP;MACV,OAAA,GAAU,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAkB,IAAlB,EAAwB,IAAxB,EAA8B,IAA9B,EAAoC,IAApC,EAA0C,MAA1C,EAAkD,KAAlD,EAAyD,KAAzD,EAAgE,IAAhE,EAAsE,IAAtE;AAEV,WAAA,yCAAA;;QACE,WAAY,CAAA,GAAA,CAAZ,GACE;UAAA,MAAA,EAAW,CAAA,SAAA;AACT,gBAAA;YAAA,CAAA,GAAI;mBACJ,SAAC,CAAD,EAAG,CAAH;cAAS,IAAG,CAAH;uBAAU,EAAA,GAAE,CAAC,SAAS,CAAC,IAAV,CAAe,IAAf,EAAqB,CAArB,CAAD,CAAF,GAA6B,EAAvC;eAAA,MAAA;uBAAgD,EAAA,GAAG,CAAH,GAAM,CAAC,SAAS,CAAC,IAAV,CAAe,IAAf,EAAqB,CAArB,CAAD,EAAtD;;YAAT;UAFS,CAAA,CAAH,CAAA,CAAR;UAGA,QAAA,EAAa,CAAA,SAAA;AACX,gBAAA;YAAA,CAAA,GAAO,GAAA,KAAO,IAAV,GAAoB,CAAC,CAArB,GAA4B,CAAC;mBACjC,SAAC,CAAD,EAAG,CAAH;AACE,kBAAA;cAAA,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAC,IAAT,CAAc,IAAd,EAAoB,CAApB,CAAP;cACJ,WAAW,CAAC,IAAZ,CAAiB,IAAjB,EAAuB,CAAvB,EAA0B,CAAA,GAAI,CAA9B;cACA,IAAG,CAAH;uBAAU,EAAV;eAAA,MAAA;uBAAiB,CAAA,GAAI,EAArB;;YAHF;UAFW,CAAA,CAAH,CAAA,CAHV;;AAFJ;AAYA,WAAA,2CAAA;;QACE,WAAY,CAAA,GAAA,CAAZ,GACE;UAAA,QAAA,EAAU,IAAV;UACA,QAAA,EAAU,QAAA,CAAS,8BAAA,GAA+B,GAA/B,GAAmC,SAA5C,CAAA,CAAA,CADV;;AAFJ;AAKA;AAAA,WAAA,wCAAA;;QACE,WAAY,CAAA,GAAA,CAAZ,GACE;UAAA,QAAA,EAAU,IAAV;UACA,QAAA,EAAU,QAAA,CAAS,kCAAA,GAAmC,GAAnC,GAAuC,SAAhD,CAAA,CAAA,CADV;;AAFJ;AAKA,WAAA,0CAAA;;QACE,KAAA,GAAQ,WAAY,CAAA,GAAA;QACpB,KAAK,CAAC,MAAN,GAAe;AAFjB;AAIA,WAAA,yCAAA;;QACE,KAAA,GAAQ,WAAY,CAAA,GAAA;QACpB,KAAK,CAAC,GAAN,GAAY;AAFd;AAKA,WAAA,2CAAA;;QACE,KAAA,GAAW,wBAAH,GAA0B,WAAY,CAAA,GAAA,CAAtC,GAAgD,WAAY,CAAA,GAAA,CAAZ,GAAmB;;UAC3E,KAAK,CAAC,SAAe,CAAA,SAAA;AACnB,gBAAA;YAAA,CAAA,GAAI;mBACJ,SAAC,CAAD,EAAG,CAAH;qBAAS,EAAA,GAAE,CAAC,SAAS,CAAC,IAAV,CAAe,IAAf,EAAqB,CAArB,CAAD,CAAF,GAA6B,CAA7B,GAAgC,CAAC,UAAA,CAAW,CAAX,CAAD;YAAzC;UAFmB,CAAA,CAAH,CAAA;;;UAGlB,KAAK,CAAC,WAAe,CAAA,SAAA;AACnB,gBAAA;YAAA,GAAA,GAAM,WAAY,CAAA,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,GAAG,CAAC,MAAJ,GAAa,CAA9B,CAAA,CAAgC,CAAC;mBACnD,SAAC,CAAD,EAAG,CAAH;qBAAS,WAAW,CAAC,IAAZ,CAAiB,IAAjB,EAAuB,CAAvB,EAA0B,GAAA,CAAI,QAAQ,CAAC,IAAT,CAAc,IAAd,EAAoB,CAApB,CAAJ,EAA4B,CAA5B,CAA1B;YAAT;UAFmB,CAAA,CAAH,CAAA;;AALpB;AASA,WAAA,kBAAA;;QACE,KAAK,CAAC,IAAN,GAAmB;QACnB,KAAK,CAAC,QAAN,GAAsB,CAAA,SAAA;AAAG,cAAA;UAAA,CAAA,GAAI;iBAAK,SAAA;mBAAG;UAAH;QAAZ,CAAA,CAAH,CAAA;QACnB,KAAK,CAAC,MAAN,GAAmB,SAAA;iBAAG,IAAC,CAAA;QAAJ;QAEnB,IAAG,qBAAA,IAAqB,kCAAxB;UACE,WAAY,CAAA,KAAK,CAAC,KAAN,CAAZ,GAA2B,IAD7B;;AALF;MAQA,OAAA,GAAa,WAAW,CAAC,MAAM,CAAC;MAChC,SAAA,GAAa,WAAY,CAAA,GAAA,CAAI,CAAC;IAjE7B,CAAA,CAAH,CAAA;;;AAqEA;;;;;;;;;;;IAUA,UAAU,CAAC,QAAX,GAAsB,SAAA,GAAY,SAAC,IAAD;AAChC,UAAA;MAAA,IAAG,gCAAH;QACS,IAAG,eAAH;iBAAiB,GAAjB;SAAA,MAAA;iBAAyB,SAAA,CAAU,EAAV,EAAzB;SADT;;AAEA,YAAU,IAAA,KAAA,CAAM,uBAAA,GAAwB,IAA9B;IAHsB;;;AAKlC;;;;;;;;;;;IAUa,oBAAC,EAAD,EAAK,WAAL;AACX,UAAA;MADgB,IAAC,CAAA,mCAAD,cAAY;MAC5B,IAAC,CAAA,QAAD,GAAc,SAAA,CAAU,EAAV;MAGd,IAAC,CAAA,QAAD,GAAY,IAAC,CAAA,QAAQ,CAAC,QAAV,KAAsB;MAClC,IAAG,IAAC,CAAA,QAAJ;AACE;AAAA,aAAA,sCAAA;;UACE,IAAG,YAAA,CAAa,SAAb,CAAA,IAA4B,CAAI,SAAS,CAAC,QAA7C;YACE,IAAC,CAAA,QAAD,GAAY;AACZ,kBAFF;;AADF,SADF;;MAOA,IAAC,CAAA,MAAD,GAAU,IAAC,CAAA,QAAQ,CAAC;MACpB,IAAG,IAAC,CAAA,MAAD,KAAW,MAAd;QACE,IAAC,CAAA,MAAD,GAAU;AACV;AAAA,aAAA,wCAAA;;UAGE,IAAG,YAAA,CAAa,SAAb,CAAA,IAA4B,SAAS,CAAC,MAAzC;YACE,IAAC,CAAA,MAAD,GAAU;AACV,kBAFF;;AAHF,SAFF;;MAWA,IAAG,IAAC,CAAA,QAAD,IAAc,IAAC,CAAA,QAAQ,CAAC,IAAV,KAAoB,OAArC;AACE,eAAW,IAAA,UAAA,CAAW,QAAX,EAAqB,CAAE,IAAC,CAAA,QAAD,CAAU,OAAV,CAAF,CAArB,EADb;;AAIA;IA5BW;;;AA8Bb;;;;;;;;yBAOA,QAAA,GAAU,SAAA;MACR,IAAoB,IAAC,CAAA,IAAD,KAAS,MAA7B;AAAA,eAAO,IAAC,CAAA,KAAR;;aACA,IAAC,CAAA,IAAD,GAAQ,UAAA,CAAW,IAAX;IAFA;;;AAIV;;;;;;;;;yBAQA,MAAA,GAAQ,SAAC,QAAD;AACN,UAAA;MAAA,IAAwB,QAAxB;AAAA,eAAO,QAAA,CAAS,IAAT,EAAP;;MACA,IAAG,IAAC,CAAA,QAAQ,CAAC,IAAV,KAAkB,QAArB;QACE,UAAA,GAAa,IAAC,CAAA,WADhB;OAAA,MAAA;QAGE,UAAA;;AAAa;AAAA;eAAA,sCAAA;;YACX,IAAG,wBAAH;2BAA0B,SAAS,CAAC,MAAV,CAAA,GAA1B;aAAA,MAAA;2BAAkD,WAAlD;;AADW;;sBAHf;;aAKA,CAAC,IAAC,CAAA,QAAQ,CAAC,IAAX,CAAgB,CAAC,MAAjB,CAAwB,UAAxB;IAPM;;;AASR;;;;;;;;;;;;yBAWA,QAAA,GAAU,SAAC,OAAD,EAAU,SAAV,EAAqB,KAArB,EAA4B,KAA5B;aACR,SAAA,CAAU,OAAV,EAAmB,IAAnB,EAAyB,SAAzB,EAAoC,KAApC,EAA2C,KAA3C;IADQ;;;;;AAxzBZ","file":"Expression.js","sourceRoot":"/source/","sourcesContent":["###\n© Copyright 2013-2016 Stephan Jorek <stephan.jorek@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n<http://www.apache.org/licenses/LICENSE-2.0>\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\nimplied. See the License for the specific language governing\npermissions and limitations under the License.\n###\n\n{Stack}         = require './Stack'\n\n{Utility:{\n  bindFunction,\n  toString,\n  isString,\n  isArray,\n  isNumber,\n  isFunction,\n  isExpression\n}}              = require './Utility'\n\nexports = module?.exports ? this\n\n###\n# # Expressions …\n# ---------------\n#\n# … are the glue between runtime-evaluation, -interpretation and\n# -compilation.  The parser emits these expressions, whereas the\n# compiler consumes them.\n###\n\n###*\n# -------------\n# @class Expression\n# @namespace GoateeScript\n###\nexports.Expression = class Expression\n\n  # Shortcuts to ease access to otherwise deeply nested properties\n  _stack        = null\n  _scope        = null\n  _errors       = null\n  _global       = null\n  _local        = null\n  _operations   = null\n  _parser       = null\n\n  # reference to `Expression.operations.scalar.name`\n  _scalar       = null\n\n  # reference to `Expression.operations['.'].name`\n  _property     = null\n\n  # static reference to a callback function\n  _callback     = null\n\n  # reference to `Expression.operations.reference.format`\n  _reference    = null\n\n  # a wrapper around `Expression.operations.reference.format`\n  _variable     = null\n\n  # reference to `Expression.operations.reference.evaluate`\n  _resolve      = null\n\n  # reference to `Expression.operations['='].evaluate`\n  _assignment   = null\n\n  ###*\n  # -------------\n  # Determine if the current state resolves to a property.  Used by\n  # `Expression.operations.reference.evaluate`\n  #\n  # @function _isProperty\n  # @return {Boolean}\n  # @private\n  ###\n  _isProperty   = () ->\n    p = _stack.previous()\n    p? and p.operator.name is _property and p.parameters[1] is _stack.current()\n\n  ###*\n  # -------------\n  # @method execute\n  # @param {Object}           context\n  # @param {Expression|mixed} expression\n  # @return {mixed}\n  # @static\n  ###\n  Expression.execute = _execute = (context, expression) ->\n    return expression unless isExpression expression\n    _stack.push context, expression\n    try\n      result = _process context, expression\n    catch e\n      (_errors ?= []).push e\n    _stack.pop()\n    return result\n\n  ###*\n  # -------------\n  # Set a static callback, to be invoked after an expression has been\n  # evaluated, but before the stack gets cleared.  Implemented as:\n  #\n  #      callback(expression, result, _stack, _errors)\n  #\n  # @method callback\n  # @param  {Function}  A callback-function (closure) to invoke\n  # @static\n  ###\n  Expression.callback = (callback) ->\n    _callback = callback\n    return\n\n  ###*\n  # -------------\n  # Get an array of all errors caught and collected during evaluation or\n  # `false` if none of them occured.\n  #\n  # @method errors\n  # @return {Boolean|Array<Error>}\n  # @static\n  ###\n  Expression.errors = () ->\n    _errors if _errors? and _errors.length isnt 0\n    false\n\n  ###*\n  # -------------\n  # This is the start and finish of evaluations.  Resets the environment before\n  # and after any execution.  This implementation avoids self-recursion as it\n  # reassigns the evaluation function.\n  #\n  # @method evaluate\n  # @param {Object}           [context]\n  # @param {Expression|mixed} [expression]\n  # @param {Object}           [variables]\n  # @param {Array}            [scope]\n  # @param {Array}            [stack]\n  # @return {mixed}\n  # @static\n  ###\n  Expression.evaluate = \\\n  _evaluate = (context={}, expression, variables, scope, stack) ->\n    return expression unless isExpression expression\n\n    isGlobalScope = not _stack?\n    if isGlobalScope\n      _stack    = new Stack(context, variables, scope, stack)\n      _scope    = _stack.scope\n      _errors   = null\n      _global   = _stack.global\n      _local    = _stack.local\n      _evaluate = _execute\n\n    result = _execute context, expression\n\n    if isGlobalScope\n      _callback(expression, result, _stack, _errors) if _callback?\n      _stack.destructor()\n      _stack    = null\n      _scope    = null\n      _global   = null\n      _local    = null\n      _evaluate = Expression.evaluate\n\n    result\n\n  ###*\n  # -------------\n  # Process the expression and evaluate its result. Chained (sub-)expressions\n  # and vector operations are resolved here.\n  #\n  # @function _process\n  # @param {Object} context\n  # @param {Expression} expression\n  # @return {mixed}\n  # @private\n  ###\n  _process = (context, expression) ->\n    {operator,parameters} = expression\n    if operator.chain\n      unless parameters.length is 2\n        throw new Error \"chain only supports 2 parameters\"\n      [left,right] = parameters\n      context = _execute context, left\n\n      if left.vector\n        values = []\n        for leftValue in context\n          rightValue = _execute leftValue, right\n          value = operator.evaluate.call leftValue, leftValue, rightValue\n          #  see if the right part of the operation is vector or not\n          if right.vector\n            unless isArray value\n              throw new Error \"vector operation did not return an array as expected: #{JSON.stringify operator}\"\n            values.push.apply values, value\n          else if value?\n            values.push value\n        return values\n\n      rightValue = _execute context, right\n      return operator.evaluate.call context, context, rightValue\n\n    if operator.raw\n      return operator.evaluate.apply context, parameters\n\n    values = []\n    values.push _execute(context, rightValue) for rightValue in parameters\n    operator.evaluate.apply context, values\n\n  ###*\n  # -------------\n  # Determine the expression's boolean value, as defined in Ecmascript 3/5/6.\n  # Therefor arrays are processed recursivly item by item and if one of them\n  # resolves to a false value, this function returns false immediatly.\n  #\n  # @method booleanize\n  # @param  {mixed}   value\n  # @return {Booelan}\n  # @static\n  ###\n  Expression.booleanize = _booleanize = (value) ->\n    if isArray value\n      for item in value\n        if _booleanize item\n          return true\n      return false\n    return Boolean value\n\n  ###*\n  # -------------\n  # Returns the given value as string.  If the given value is not an expression\n  # `JSON.stringify` will be called to deliver the result.  If the expression's\n  # operator has a `format` function (see Èxpression.operations` below) it will\n  # be called with the expression parameters, otherwise a string will be build\n  # from those parameters.\n  #\n  # @method stringify\n  # @param  {mixed}   value\n  # @return {String}\n  # @static\n  ###\n  Expression.stringify = _stringify = (value) ->\n    if not isExpression value\n      return JSON.stringify value\n\n    {operator,parameters} = value\n    {format}              = operator\n\n    if format?\n      return format.apply this, parameters\n    else if parameters.length is 2\n      # basic operations\n      \"#{_stringify parameters[0]}#{operator}#{_stringify parameters[1]}\"\n    else\n      # block statements and … ?\n      format = []\n      format.push _stringify(parameter) for parameter in parameters\n      format.join ' '\n\n  ###*\n  # -------------\n  # A dictionary of all known operations an expression might perform.\n  # Used during runtime interpretation, stringification and compilation.\n  #\n  # @property operations\n  # @type {Object}\n  # @static\n  ###\n  Expression.operations = _operations =\n\n    # An assignment, filled below\n    '=':\n      evaluate: (a,b) ->\n        _local[a] = b\n\n    # Assigment operations are filled below (`_assign`)\n    #\n    #     '-='  : {}\n    #     '+='  : {}\n    #     '*='  : {}\n    #     '/='  : {}\n    #     '%='  : {}\n    #     '^='  : {}\n    #     '>>>=': {}\n    #     '>>=' : {}\n    #     '<<=' : {}\n    #     '&='  : {}\n    #     '|='  : {}\n\n    # Increment and decrement operation are filled below (`_incdec`)\n    #\n    #     '++':\n    #       format: (a,b) ->\n    #         if b then \"#{_stringify(a)}++\" else \"++#{_stringify(a)}\"\n    #       evaluate: (a,b) ->\n    #         c = _operations.reference.evaluate(a)\n    #         _assignment.call(this, a, c + 1)\n    #         if b then c else c + 1\n    #     '--':\n    #       format: (a,b) ->\n    #         if b then \"#{_stringify(a)}--\" else \"--#{_stringify(a)}\"\n    #       evaluate: (a,b) ->\n    #         c = _operations.reference.evaluate(a)\n    #         _assignment.call(this, a, c - 1)\n    #         if b then c else c - 1\n\n    # An object's property\n    '.':\n      chain   : true\n\n      # The formatter is not needed anymore\n      #\n      #      format  : (a,b) -> \"#{_stringify a}.#{_stringify b}\"\n\n      # a.b with a <- b\n      #\n      # Function (b) bound to its container (a) now, otherwise it would have\n      # the _global context as its scope.  If the container (a) is the _global\n      # context, (b) has already been bound to (a), hence (b) is returned as it\n      # is to avoid binding it twice.\n      evaluate: (a,b) ->\n        if a isnt _global and isFunction b then bindFunction b, a else b\n\n    # Negation and bitwise inversion operations are filled below (`_single`)\n    #\n    #     '!':\n    #       constant: true\n    #       evaluate: (a) -> !a\n    #     '~':\n    #       constant: true\n    #       evaluate: (a) -> ~a\n\n    # Mathemetical and bitwise operations which can not resolve early\n    # are filled below (`_pair`)\n    #\n    #     '+':\n    #       constant: true\n    #       evaluate: (a,b) -> a + b\n    #     '-':\n    #       constant: true\n    #       evaluate: (a,b) -> a - b\n    #     '*':\n    #       constant: true\n    #       evaluate: (a,b) -> a * b\n    #     '/':\n    #       constant: true\n    #       evaluate: (a,b) -> a / b\n    #     '%':\n    #       constant: true\n    #       evaluate: (a,b) -> a % b\n    #     '^':\n    #       constant: true\n    #       evaluate: (a,b) -> a ^ b\n    #     '>>>':\n    #       constant: true\n    #       evaluate: (a,b) -> a >>> b\n    #     '>>':\n    #       constant: true\n    #       evaluate: (a,b) -> a >> b\n    #     '<<':\n    #       constant: true\n    #       evaluate: (a,b) -> a << b\n    #     '&':\n    #       constant: true\n    #       evaluate: (a,b) -> a & b\n    #     '|':\n    #       constant: true\n    #       evaluate: (a,b) -> a | b\n\n\n    # Early resolving boolean `and`\n    '&&':\n      raw     : true\n      constant: true\n      evaluate: (a,b) ->\n        a = _execute this, a\n        if not a\n          return a\n        b = _execute this, b\n        return b\n\n    # Early resolving boolean `or`\n    '||':\n      raw     : true\n      constant: true\n      evaluate: (a,b) ->\n        a = _execute this, a\n        if a\n          return a\n        b = _execute this, b\n        return b\n\n    # Boolean operations which can not resolve early are filled below (`_bools`)\n    #\n    #     '<':\n    #       constant: true\n    #       vector: false\n    #       evaluate: (a,b) -> a < b\n    #     '>':\n    #       constant: true\n    #       vector: false\n    #       evaluate: (a,b) -> a > b\n    #     '<=':\n    #       constant: true\n    #       vector: false\n    #       evaluate: (a,b) -> a <= b\n    #     '>=':\n    #       constant: true\n    #       vector: false\n    #       evaluate: (a,b) -> a >= b\n    #     '===':\n    #       constant: true\n    #       vector: false\n    #       evaluate: (a,b) -> `a === b`\n    #     '!==':\n    #       constant: true\n    #       vector: false\n    #       evaluate: (a,b) -> `a !== b`\n\n    # Boolean operations which can not resolve early and keep their paramters as\n    # raw values are filled below (`_raws`)\n    #\n    #     '==':\n    #       constant: true\n    #       vector: false\n    #       raw     : true\n    #       evaluate: (a,b) ->\n    #         return `a == b`\n    #         #     return `a[0] == b` if isArray a and a.length is 1\n    #         #     return `a == b[0]` if isArray b and b.length is 1\n    #     '!=':\n    #       constant: true\n    #       vector: false\n    #       raw     : true\n    #       evaluate: (a,b) ->\n    #         return `a != b`\n    #         #     return `a[0] != b` if isArray a and a.length is 1\n    #         #return `a != b[0]` if isArray b and b.length is 1\n\n    # Ternary conditional clause\n    '?:':\n      constant: true\n      raw     : true\n      vector: false\n      format: (a,b,c) ->\n        \"(#{_stringify(a)}?#{_stringify(b)}:#{_stringify(c)})\"\n      evaluate: (a,b,c) ->\n        a = _execute this, a\n        _execute this, if _booleanize a then b else c\n\n    # Function call\n    '()':\n      vector: false\n      format: (f,a...) ->\n        f + '(' + a.join(',') + ')'\n      evaluate: (f,a...) ->\n        throw new Error \"Missing argument to call.\" unless f?\n        throw new Error \"Given argument is not callable.\" unless isFunction f\n        f.apply this, a\n\n    # Array accessor\n    '[]':\n      chain: false\n      vector: false\n      format: (a,b) -> \"#{a}[#{b}]\"\n      evaluate: (a,b) ->\n        #  support negative indexers, if you literally\n        #  want \"-1\" then use a string literal\n        if isNumber(b) and b < 0\n          a[(if a.length? then a.length else 0) + b]\n        else\n          a[b]\n\n    # We dont support predicates, but might want to do so in future.\n    #\n    #     '{}':\n    #       chain: true\n    #       vector: false\n    #       format: (a,b) -> \"#{a}{#{b}}\"\n    #       evaluate: (a,b) -> if _booleanize b then a else undefined\n\n    # Contexts resolve much more detailed, see below.\n    #\n    #     '$':\n    #       format: -> '$'\n    #       vector: false\n    #       evaluate: -> _global\n    #     '@':\n    #       format: -> '@'\n    #       vector: false\n    #       evaluate: -> this\n    context:\n      alias   : 'c'\n      format  : (c) ->\n        switch c\n          when \"@\"  then \"this\"\n          when \"$$\" then \"_global\"\n          when \"$_\" then \"_local\"\n          when \"_$\" then \"_scope\"\n          when \"__\" then \"_stack\"\n          when \"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\", \"$9\"\n            \"_scope[#{c[1]}]\"\n          when \"_0\", \"_1\", \"_2\", \"_3\", \"_4\", \"_5\", \"_6\", \"_7\", \"_8\", \"_9\"\n            \"_scope[_scope.length-#{c[1]+1}]\"\n          else \"undefined\"\n      vector  : false\n      evaluate: (c) ->\n        switch c\n          when \"@\"  then this\n          when \"$$\" then _global\n          when \"$_\" then _local\n          when \"_$\" then _scope\n          when \"__\" then _stack.stack\n          when \"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\", \"$9\", \\\n               \"_0\", \"_1\", \"_2\", \"_3\", \"_4\", \"_5\", \"_6\", \"_7\", \"_8\", \"_9\"\n            _scope[if c[0] is \"$\" then c[1] else _scope.length-c[1]-1]\n          else undefined\n\n    # A property-value\n    property:\n      alias   : 'p'\n      format  : (a) -> a\n      vector  : false\n      evaluate: (a) ->\n        if a is \"constructor\" or a is \"__proto__\" or a is \"prototype\"\n          undefined\n        else\n          this[a]\n\n    # A local variable or context reference from scope\n    reference:\n      alias : 'r'\n      format: (a) ->\n        if a is \"this\"\n          \"this\"\n        else\n          \"_resolve(this,#{JSON.stringify a}).#{a}\"\n      vector  : false\n      evaluate: (a) ->\n        if a is \"this\"\n          this\n        else if a is \"constructor\" or a is \"__proto__\" or a is \"prototype\"\n          undefined\n        else\n          v = this[a]\n          if this is _local\n            return v\n          if _isProperty()\n            return v if this.hasOwnProperty a\n          else\n            return _local[a] if _local.hasOwnProperty a\n            #  walk the context stack from top to bottom looking for value\n            for c in _scope by -1 when c.hasOwnProperty a\n              return c[a]\n          v\n\n    # We dont support children, because we dont't want to deeply clone array\n    # values or opbject properties.  But we might want to do so in future, if\n    # we can get rid of the `underscore`-dependency.\n    #\n    #     children:\n    #       alias   : 'C'\n    #       format  : -> '*'\n    #       vector  : true\n    #       evaluate: () ->\n    #         if isArray @\n    #           _.clone @\n    #         else\n    #           _.values @\n\n    # A number, string, boolean or null\n    scalar:\n      alias   : 's'\n      constant: true\n      vector  : false\n      format  : (a) -> if a is undefined then '' else JSON.stringify a\n      evaluate: (a) -> a\n\n    # A block of statements seperated by semicolon\n    block:\n      alias   : 'b'\n      format  : (s...) -> s.join ';'\n      evaluate: -> arguments[arguments.length-1]\n\n    # A list of statements seperated by comma\n    list:\n      alias   : 'l'\n      format  : (s...) -> \"#{s.join ','}\"\n      evaluate: -> arguments[arguments.length-1]\n\n    # A group covers the list from above with parenthesis\n    group:\n      alias   : 'g'\n      format  : (l) -> \"(#{l})\"\n      evaluate: (l) -> _execute this, l\n\n    # An early resolving `if`/`else` statement, uses `Expression.booleanize`\n    # to determine the “truth” of parameter `a`.\n    if:\n      alias   : 'i'\n      raw     : true\n      format  : (a,b,c) ->\n        if c?\n          \"if #{a} {#{b}} else {#{c}}\"\n        else\n          \"if #{a} {#{b}}\"\n      evaluate: (a,b,c) ->\n        if _booleanize _execute(this, a)\n          _execute this, b\n        else if c?\n          _execute this, c\n        else\n          undefined\n\n    # We dont't support iterations, but might want to do so in future.\n    #\n    #     for:\n    #       alias   : 'f'\n    #       raw     : true\n    #       format  : (a,b) -> \"for #{a} {#{b}}\"\n    #       evaluate: (a,b) ->\n    #         a = _execute this, a\n    #         return undefined unless a?\n    #         for value in _.values a\n    #          _execute value, b\n\n    # An array of values\n    array:\n      alias   : 'a'\n      format  : (e...) -> \"[#{e.join ','}]\"\n      evaluate: (e...) -> e\n\n    # An object of keys and values.\n    object:\n      alias   : 'o'\n      format  : ->\n        o = []\n        o.push \"#{k}:#{arguments[i+1]}\" for k,i in arguments by 2\n        \"{#{o.join ','}}\"\n      evaluate: ->\n        o = {}\n        o[k] = arguments[i+1] for k,i in arguments by 2\n        o\n\n  ###*\n  # -------------\n  # Fill and add missing `Expression.operations`\n  #\n  # @function\n  # @private\n  ###\n  do ->\n\n    _reference  = _operations.reference.format\n    _variable   = (a) ->\n      _reference.call(this, a).replace(/^_resolve/,'_variable')\n\n    _resolve    = _operations.reference.evaluate\n    _assignment = _operations['='].evaluate\n\n    _incdec = ['++', '--']\n    _single = ['!', '~', ]\n    _pairs  = ['+', '-', '*', '/', '%', '^', '>>>', '>>', '<<', '&', '|']\n    _bools  = ['<', '>', '<=', '>=', '===', '!==']\n    _raws   = ['==', '!=']\n    _assign = ['=', '-=', '+=', '*=', '/=', '%=', '^=', '>>>=', '>>=', '<<=', '&=', '|=']\n\n    for key in _incdec\n      _operations[key] =\n        format: do ->\n          k = key\n          (a,b) -> if b then \"#{_variable.call(this, a)}#{k}\" else \"#{k}#{_variable.call(this, a)}\"\n        evaluate: do ->\n          i = if key is \"++\" then +1 else -1\n          (a,b) ->\n            c = Number(_resolve.call(this, a))\n            _assignment.call(this, a, c + i)\n            if b then c else c + i\n\n    for key in _single\n      _operations[key] =\n        constant: true\n        evaluate: Function(\"return function(a) { return #{key} a ; };\")()\n\n    for key in _pairs.concat(_bools).concat(_raws)\n      _operations[key] =\n        constant: true\n        evaluate: Function(\"return function(a,b) { return a #{key} b ; };\")()\n\n    for key in _bools\n      value = _operations[key]\n      value.vector = false\n\n    for key in _raws\n      value = _operations[key]\n      value.raw = true\n\n    # process assigments and equality\n    for key in _assign\n      value = if _operations[key]? then _operations[key] else _operations[key] = {}\n      value.format   ?= do ->\n        k = key\n        (a,b) -> \"#{_variable.call(this, a)}#{k}#{_stringify(b)}\"\n      value.evaluate ?= do ->\n        _op = _operations[key.substring 0, key.length - 1].evaluate\n        (a,b) -> _assignment.call this, a, _op(_resolve.call(this, a), b)\n\n    for key, value of _operations\n      value.name       = key\n      value.toString   = do -> k = key; -> k\n      value.toJSON     = -> @name\n      # process assigments and equality\n      if value.alias? and not _operations[value.alias]?\n        _operations[value.alias] = key\n\n    _scalar    = _operations.scalar.name\n    _property  = _operations['.'].name\n\n    return\n\n  ###*\n  # -------------\n  # Lookup an operation by its name (~ key in `Expression.operations`)\n  #\n  # @method operator\n  # @param  {String}  name\n  # @return {Object}\n  # @throws {Error}\n  # @static\n  ###\n  Expression.operator = _operator = (name) ->\n    if (op = _operations[name])?\n      return if op.name? then op else _operator op\n    throw new Error \"operation not found: #{name}\"\n\n  ###*\n  # -------------\n  # The expressions constructor.  Depending on the operations' constant and\n  # vector the given paramters might get evaluated here, to save nesting depth.\n  #\n  # @param  {String} op             expression's operation name\n  # @param  {Array}  [parameters]   optional array of parameters\n  # @return {Expression|void}       expression or an early resolved new instance\n  # @constructor\n  ###\n  constructor: (op, @parameters=[]) ->\n    @operator   = _operator(op)\n\n    #  is this expression a constant?\n    @constant = @operator.constant is true\n    if @constant\n      for parameter in @parameters\n        if isExpression(parameter) and not parameter.constant\n          @constant = false\n          break\n\n    #  does this expression yield a vector result?\n    @vector = @operator.vector\n    if @vector is undefined\n      @vector = false     #   assume false\n      for parameter in @parameters\n        # if the parameter has a vector quantity\n        # then the result is a vector result\n        if isExpression(parameter) and parameter.vector\n          @vector = true\n          break\n\n    #  if this expression is a constant then we pre-evaluate it now\n    #  and just return a scalar expression with the result\n    if @constant and @operator.name isnt _scalar\n      return new Expression 'scalar', [ @evaluate _global ]\n\n    #  otherwise return this expression\n    return\n\n  ###*\n  # -------------\n  # Allows expressions to be turned into strings\n  #\n  # @method toString\n  # @return {String}\n  ###\n  toString: ->\n    return @text unless @text is undefined\n    @text = _stringify this\n\n  ###*\n  # -------------\n  # Allows expression to be turned into a kind of json-ast.  See\n  # `Compiler.coffee` for a complete ast-implementation\n  #\n  # @method toJSON\n  # @return {Object.<String:op,Array:parameters>}\n  ###\n  toJSON: (callback) ->\n    return callback this if callback\n    if @operator.name is 'scalar'\n      parameters = @parameters\n    else\n      parameters = for parameter in @parameters\n        if parameter.toJSON? then parameter.toJSON() else parameter\n    [@operator.name].concat parameters\n\n  ###*\n  # -------------\n  # Evaluate this expressions value\n  #\n  # @method evaluate\n  # @param {Object} [context]\n  # @param {Object} [variables]\n  # @param {Array}  [scope]\n  # @param {Array}  [stack]\n  # @return {mixed}\n  ###\n  evaluate: (context, variables, scope, stack) ->\n    _evaluate context, this, variables, scope, stack\n"]}